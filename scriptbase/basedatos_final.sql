-- ============================================================
-- SCRIPT COMPLETO DE BASE DE DATOS - VERSIÓN LIMPIA
-- Banco - Sistema de Gestión Bancaria
-- ============================================================
-- Este script contiene la estructura completa de la base de datos:
-- - Roles
-- - Tablas
-- - Índices
-- - Triggers
-- - Vistas
-- - Packages (procedimientos almacenados)
-- - Grants (permisos)
--
-- Fecha de creación: 17 de Noviembre de 2025
-- Versión: Limpia (sin prefijo BANCO, sin INSERTs)
--
-- NOTA: Este script NO incluye el prefijo BANCO. en los nombres
-- de tablas. Todas las tablas se crean sin prefijo.
-- NO incluye INSERTs de datos.
-- ============================================================

-- ============================================================
-- PARTE 1: ROLES
-- ============================================================

CREATE ROLE ROL_ADMIN;
CREATE ROLE ROL_CLIENTE;

-- ============================================================
-- PARTE 2: TABLAS
-- ============================================================

--------------------------------------------------------
--  DDL for Table ABONO_EXTRAORDINARIO
--------------------------------------------------------

  CREATE TABLE "ABONO_EXTRAORDINARIO" 
   (	"ID_ABONO" NUMBER(12,0), 
	"ID_PRESTAMO" NUMBER(12,0), 
	"ID_TRANSACCION" NUMBER(12,0), 
	"MONTO_ABONO" NUMBER(15,2), 
	"FECHA_ABONO" TIMESTAMP (6), 
	"TIPO_ABONO" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "ABONO_EXTRAORDINARIO" TO "ROL_ADMIN";
  GRANT INSERT ON "ABONO_EXTRAORDINARIO" TO "ROL_ADMIN";
  GRANT SELECT ON "ABONO_EXTRAORDINARIO" TO "ROL_ADMIN";
  GRANT UPDATE ON "ABONO_EXTRAORDINARIO" TO "ROL_ADMIN";
  GRANT SELECT ON "ABONO_EXTRAORDINARIO" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table ADMINISTRADOR
--------------------------------------------------------

  CREATE TABLE "ADMINISTRADOR" 
   (	"ID_ADMINISTRADOR" NUMBER(12,0), 
	"FECHA_ASIGNACION_ADMINISTRADOR" TIMESTAMP (6), 
	"EMAIL_ADMINISTRADOR" VARCHAR2(120 BYTE), 
	"CONTRASENA_ADMINISTRADOR" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "ADMINISTRADOR" TO "ROL_ADMIN";
  GRANT INSERT ON "ADMINISTRADOR" TO "ROL_ADMIN";
  GRANT SELECT ON "ADMINISTRADOR" TO "ROL_ADMIN";
  GRANT UPDATE ON "ADMINISTRADOR" TO "ROL_ADMIN";
--------------------------------------------------------
--  DDL for Table AUDITORIA_CAMBIOS
--------------------------------------------------------

  CREATE TABLE "AUDITORIA_CAMBIOS" 
   (	"ID_AUDITORIA" NUMBER(12,0), 
	"TABLA_AFECTADA" VARCHAR2(50 BYTE), 
	"ID_REGISTRO" VARCHAR2(50 BYTE), 
	"CAMPO_MODIFICADO" VARCHAR2(50 BYTE), 
	"VALOR_ANTERIOR" VARCHAR2(4000 BYTE), 
	"VALOR_NUEVO" VARCHAR2(4000 BYTE), 
	"TIPO_OPERACION" VARCHAR2(10 BYTE), 
	"FECHA_CAMBIO" TIMESTAMP (6) DEFAULT SYSTIMESTAMP, 
	"USUARIO_ORACLE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table CAJERO
--------------------------------------------------------

  CREATE TABLE "CAJERO" 
   (	"ID_CAJERO" NUMBER(12,0), 
	"ID_SUCURSAL" NUMBER(12,0), 
	"ID_ADMINISTRADOR" NUMBER(12,0), 
	"DINERO_DISPONIBLE_CAJERO" NUMBER(15,2), 
	"ESTADO_CAJERO" VARCHAR2(20 BYTE), 
	"FECHA_ULTIMA_RECARGA_CAJERO" TIMESTAMP (6)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "CAJERO" TO "ROL_ADMIN";
  GRANT INSERT ON "CAJERO" TO "ROL_ADMIN";
  GRANT SELECT ON "CAJERO" TO "ROL_ADMIN";
  GRANT UPDATE ON "CAJERO" TO "ROL_ADMIN";
--------------------------------------------------------
--  DDL for Table CLIENTE
--------------------------------------------------------

  CREATE TABLE "CLIENTE" 
   (	"NOMBRE_CLIENTE" VARCHAR2(120 BYTE), 
	"EMAIL_CLIENTE" VARCHAR2(120 BYTE), 
	"TELEFONO_CLIENTE" VARCHAR2(30 BYTE), 
	"ESTADO_CLIENTE" VARCHAR2(10 BYTE), 
	"FECHA_REGISTRO_CLIENTE" TIMESTAMP (6), 
	"CEDULA_CLIENTE" NUMBER(12,0), 
	"ID_CLIENTE" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "CLIENTE" TO "ROL_ADMIN";
  GRANT INSERT ON "CLIENTE" TO "ROL_ADMIN";
  GRANT SELECT ON "CLIENTE" TO "ROL_ADMIN";
  GRANT UPDATE ON "CLIENTE" TO "ROL_ADMIN";
  GRANT SELECT ON "CLIENTE" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table CUENTA
--------------------------------------------------------

  CREATE TABLE "CUENTA" 
   (	"ID_CUENTA" NUMBER(12,0), 
	"ID_CLIENTE" VARCHAR2(10 BYTE), 
	"ID_ADMINISTRADOR" NUMBER(12,0), 
	"SALDO_CUENTA" NUMBER(15,2), 
	"FECHA_CREACION_CUENTA" TIMESTAMP (6), 
	"ESTADO_CUENTA" VARCHAR2(10 BYTE), 
	"FECHA_ULTIMA_TRANSACCION_CUENTA" TIMESTAMP (6), 
	"CONTRASENA_CUENTA" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "CUENTA" TO "ROL_ADMIN";
  GRANT INSERT ON "CUENTA" TO "ROL_ADMIN";
  GRANT SELECT ON "CUENTA" TO "ROL_ADMIN";
  GRANT UPDATE ON "CUENTA" TO "ROL_ADMIN";
  GRANT SELECT ON "CUENTA" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table CUOTA
--------------------------------------------------------

  CREATE TABLE "CUOTA" 
   (	"ID_CUOTA" NUMBER(12,0), 
	"ID_PRESTAMO" NUMBER(12,0), 
	"NUMERO_CUOTA" NUMBER(6,0), 
	"MONTO_DE_CUOTA" NUMBER(15,2), 
	"CAPITAL_CUOTA" NUMBER(15,2), 
	"FECHA_DE_VENCIMIENTO_CUOTA" TIMESTAMP (6), 
	"FECHA_DE_PAGO_CUOTA" TIMESTAMP (6), 
	"ESTADO_CUOTA" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "CUOTA" TO "ROL_ADMIN";
  GRANT INSERT ON "CUOTA" TO "ROL_ADMIN";
  GRANT SELECT ON "CUOTA" TO "ROL_ADMIN";
  GRANT UPDATE ON "CUOTA" TO "ROL_ADMIN";
  GRANT SELECT ON "CUOTA" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table PRESTAMO
--------------------------------------------------------

  CREATE TABLE "PRESTAMO" 
   (	"ID_PRESTAMO" NUMBER(12,0), 
	"ID_SUCURSAL" NUMBER(12,0), 
	"MONTO_PRESTAMO" NUMBER(15,2), 
	"TASA_DE_INTERES_PRESTAMO" NUMBER(5,2), 
	"PLAZO_PRESTAMO" NUMBER(6,0), 
	"FECHA_INICIO_PRESTAMO" TIMESTAMP (6), 
	"FECHA_VENCIMIENTO_PRESTAMO" TIMESTAMP (6), 
	"ESTADO_PRESTAMO" VARCHAR2(12 BYTE), 
	"FECHA_ULTIMO_PAGO_PRESTAMO" TIMESTAMP (6), 
	"SALDO_PRESTAMO" NUMBER(15,2), 
	"ID_CUENTA" NUMBER(12,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "PRESTAMO" TO "ROL_ADMIN";
  GRANT INSERT ON "PRESTAMO" TO "ROL_ADMIN";
  GRANT SELECT ON "PRESTAMO" TO "ROL_ADMIN";
  GRANT UPDATE ON "PRESTAMO" TO "ROL_ADMIN";
  GRANT SELECT ON "PRESTAMO" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table SUCURSAL
--------------------------------------------------------

  CREATE TABLE "SUCURSAL" 
   (	"ID_SUCURSAL" NUMBER(12,0), 
	"NOMBRE_SUCURSAL" VARCHAR2(120 BYTE), 
	"DIRECCION_SUCURSAL" VARCHAR2(200 BYTE), 
	"TELEFONO_SUCURSAL" VARCHAR2(30 BYTE), 
	"ESTADO_SUCURSAL" VARCHAR2(10 BYTE), 
	"ID_ADMINISTRADOR" NUMBER(12,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "SUCURSAL" TO "ROL_ADMIN";
  GRANT INSERT ON "SUCURSAL" TO "ROL_ADMIN";
  GRANT SELECT ON "SUCURSAL" TO "ROL_ADMIN";
  GRANT UPDATE ON "SUCURSAL" TO "ROL_ADMIN";
--------------------------------------------------------
--  DDL for Table TARJETA
--------------------------------------------------------

  CREATE TABLE "TARJETA" 
   (	"ID_TARJETA" NUMBER(12,0), 
	"ID_CUENTA" NUMBER(12,0), 
	"NUMERO_TARJETA" VARCHAR2(25 BYTE), 
	"CVV_TARJETA" VARCHAR2(3 BYTE), 
	"FECHA_EMISION_TARJETA" TIMESTAMP (6), 
	"FECHA_VENCIMIENTO_TARJETA" TIMESTAMP (6), 
	"ESTADO_TARJETA" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "TARJETA" TO "ROL_ADMIN";
  GRANT INSERT ON "TARJETA" TO "ROL_ADMIN";
  GRANT SELECT ON "TARJETA" TO "ROL_ADMIN";
  GRANT UPDATE ON "TARJETA" TO "ROL_ADMIN";
  GRANT SELECT ON "TARJETA" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table TARJETA_CREDITO
--------------------------------------------------------

  CREATE TABLE "TARJETA_CREDITO" 
   (	"ID_TARJETA" NUMBER(12,0), 
	"TASA_INTERES_CREDITO" NUMBER(5,2), 
	"LIMITE_CREDITO" NUMBER(15,2), 
	"CUOTA_MANEJO_CREDITO" NUMBER(15,2), 
	"FECHA_PAGO_CREDITO" TIMESTAMP (6), 
	"FECHA_CORTE_CREDITO" NUMBER(2,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "TARJETA_CREDITO" TO "ROL_ADMIN";
  GRANT INSERT ON "TARJETA_CREDITO" TO "ROL_ADMIN";
  GRANT SELECT ON "TARJETA_CREDITO" TO "ROL_ADMIN";
  GRANT UPDATE ON "TARJETA_CREDITO" TO "ROL_ADMIN";
  GRANT SELECT ON "TARJETA_CREDITO" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table TARJETA_DEBITO
--------------------------------------------------------

  CREATE TABLE "TARJETA_DEBITO" 
   (	"ID_TARJETA" NUMBER(12,0), 
	"LIMITE_RETIRO_DEBITO" NUMBER(15,2), 
	"SALDO_ACTUAL_DEBITO" NUMBER(15,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "TARJETA_DEBITO" TO "ROL_ADMIN";
  GRANT INSERT ON "TARJETA_DEBITO" TO "ROL_ADMIN";
  GRANT SELECT ON "TARJETA_DEBITO" TO "ROL_ADMIN";
  GRANT UPDATE ON "TARJETA_DEBITO" TO "ROL_ADMIN";
  GRANT SELECT ON "TARJETA_DEBITO" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for Table TRANSACCION
--------------------------------------------------------

  CREATE TABLE "TRANSACCION" 
   (	"ID_TRANSACCION" NUMBER(12,0), 
	"ID_CAJERO" NUMBER(12,0), 
	"ID_TARJETA" NUMBER(12,0), 
	"ID_CUENTA_ORIGEN" NUMBER(12,0), 
	"ID_CUENTA_DESTINO" NUMBER(12,0), 
	"FECHA_TRANSACCION" TIMESTAMP (6), 
	"TIPO_TRANSACCION" VARCHAR2(20 BYTE), 
	"MONTO_TRANSACCION" NUMBER(15,2), 
	"ESTADO_TRANSACCION" VARCHAR2(12 BYTE), 
	"DESCRIPCION_TRANSACCION" VARCHAR2(45 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
  GRANT DELETE ON "TRANSACCION" TO "ROL_ADMIN";
  GRANT INSERT ON "TRANSACCION" TO "ROL_ADMIN";
  GRANT SELECT ON "TRANSACCION" TO "ROL_ADMIN";
  GRANT UPDATE ON "TRANSACCION" TO "ROL_ADMIN";
  GRANT SELECT ON "TRANSACCION" TO "ROL_CLIENTE";
--------------------------------------------------------
--  DDL for View VW_CAJEROS_COMPLETOS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "VW_CAJEROS_COMPLETOS" ("ID_CAJERO", "DINERO_DISPONIBLE_CAJERO", "ESTADO_CAJERO", "ID_SUCURSAL", "NOMBRE_SUCURSAL", "DIRECCION_SUCURSAL") AS 
  SELECT 
    cj.id_cajero,
    cj.dinero_disponible_cajero,
    cj.estado_cajero,
    s.id_sucursal,
    s.nombre_sucursal,
    s.direccion_sucursal
FROM cajero cj
JOIN sucursal s ON cj.id_sucursal = s.id_sucursal
;
--------------------------------------------------------
--  DDL for View VW_CLIENTES_COMPLETOS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "VW_CLIENTES_COMPLETOS" ("ID_CLIENTE", "NOMBRE_CLIENTE", "EMAIL_CLIENTE", "TELEFONO_CLIENTE", "CEDULA_CLIENTE", "ESTADO_CLIENTE", "TOTAL_CUENTAS") AS 
  SELECT 
    c.id_cliente,
    c.nombre_cliente,
    c.email_cliente,
    c.telefono_cliente,
    c.cedula_cliente,
    c.estado_cliente,
    COUNT(cu.id_cuenta) AS total_cuentas
FROM cliente c
LEFT JOIN cuenta cu ON c.id_cliente = cu.id_cliente
GROUP BY c.id_cliente, c.nombre_cliente, c.email_cliente, 
         c.telefono_cliente, c.cedula_cliente, c.estado_cliente
;
--------------------------------------------------------
--  DDL for View VW_CUENTAS_COMPLETAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "VW_CUENTAS_COMPLETAS" ("ID_CUENTA", "SALDO_CUENTA", "ESTADO_CUENTA", "FECHA_CREACION_CUENTA", "ID_CLIENTE", "NOMBRE_CLIENTE", "EMAIL_CLIENTE") AS 
  SELECT 
    cu.id_cuenta,
    cu.saldo_cuenta,
    cu.estado_cuenta,
    cu.fecha_creacion_cuenta,
    c.id_cliente,
    c.nombre_cliente,
    c.email_cliente
FROM cuenta cu
JOIN cliente c ON cu.id_cliente = c.id_cliente
;
--------------------------------------------------------
--  DDL for View VW_PRESTAMOS_COMPLETOS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "VW_PRESTAMOS_COMPLETOS" ("ID_PRESTAMO", "MONTO_PRESTAMO", "SALDO_PRESTAMO", "ESTADO_PRESTAMO", "ID_CUENTA", "TOTAL_CUOTAS", "CUOTAS_PAGADAS") AS 
  SELECT 
    p.id_prestamo,
    p.monto_prestamo,
    p.saldo_prestamo,
    p.estado_prestamo,
    p.id_cuenta,
    COUNT(cu.id_cuota) AS total_cuotas,
    COUNT(CASE WHEN cu.estado_cuota = 'pagada' THEN 1 END) AS cuotas_pagadas
FROM prestamo p
LEFT JOIN cuota cu ON p.id_prestamo = cu.id_prestamo
GROUP BY p.id_prestamo, p.monto_prestamo, p.saldo_prestamo, 
         p.estado_prestamo, p.id_cuenta
;
--------------------------------------------------------
--  DDL for View VW_TARJETAS_COMPLETAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "VW_TARJETAS_COMPLETAS" ("ID_TARJETA", "NUMERO_TARJETA", "ESTADO_TARJETA", "ID_CUENTA", "TIPO_TARJETA", "LIMITE") AS 
  SELECT 
    t.id_tarjeta,
    t.numero_tarjeta,
    t.estado_tarjeta,
    t.id_cuenta,
    CASE 
        WHEN tc.id_tarjeta IS NOT NULL THEN 'CREDITO'
        WHEN td.id_tarjeta IS NOT NULL THEN 'DEBITO'
        ELSE 'DESCONOCIDO'
    END AS tipo_tarjeta,
    NVL(tc.limite_credito, td.limite_retiro_debito) AS limite
FROM tarjeta t
LEFT JOIN tarjeta_credito tc ON t.id_tarjeta = tc.id_tarjeta
LEFT JOIN tarjeta_debito td ON t.id_tarjeta = td.id_tarjeta
;
--------------------------------------------------------
--  DDL for View VW_TRANSACCIONES_COMPLETAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "VW_TRANSACCIONES_COMPLETAS" ("ID_TRANSACCION", "MONTO_TRANSACCION", "FECHA_TRANSACCION", "ESTADO_TRANSACCION", "TIPO_TRANSACCION", "CUENTA_ORIGEN_ID", "SALDO_ORIGEN", "CUENTA_DESTINO_ID", "SALDO_DESTINO") AS 
  SELECT 
    tr.id_transaccion,
    tr.monto_transaccion,
    tr.fecha_transaccion,
    tr.estado_transaccion,
    tr.tipo_transaccion,
    co.id_cuenta AS cuenta_origen_id,
    co.saldo_cuenta AS saldo_origen,
    cd.id_cuenta AS cuenta_destino_id,
    cd.saldo_cuenta AS saldo_destino
FROM transaccion tr
LEFT JOIN cuenta co ON tr.id_cuenta_origen = co.id_cuenta
LEFT JOIN cuenta cd ON tr.id_cuenta_destino = cd.id_cuenta
;
--------------------------------------------------------
--  DDL for Index PK_PRESTAMO
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_PRESTAMO" ON "PRESTAMO" ("ID_PRESTAMO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_CUOTA_PRESTAMO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UQ_CUOTA_PRESTAMO" ON "CUOTA" ("ID_PRESTAMO", "NUMERO_CUOTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TARJETA_DEBITO
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_TARJETA_DEBITO" ON "TARJETA_DEBITO" ("ID_TARJETA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_TRANSACCION_MONTO_COMPLETADA
--------------------------------------------------------

  CREATE INDEX "IDX_TRANSACCION_MONTO_COMPLETADA" ON "TRANSACCION" (CASE "ESTADO_TRANSACCION" WHEN 'completada' THEN "MONTO_TRANSACCION" ELSE NULL END ) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TARJETA_CREDITO
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_TARJETA_CREDITO" ON "TARJETA_CREDITO" ("ID_TARJETA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_PRESTAMO_CUENTA
--------------------------------------------------------

  CREATE INDEX "IDX_PRESTAMO_CUENTA" ON "PRESTAMO" ("ID_CUENTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_CLIENTE_CEDULA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UQ_CLIENTE_CEDULA" ON "CLIENTE" ("CEDULA_CLIENTE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_CAJERO
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_CAJERO" ON "CAJERO" ("ID_CAJERO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_TRANSACCION_FECHA
--------------------------------------------------------

  CREATE INDEX "IDX_TRANSACCION_FECHA" ON "TRANSACCION" ("FECHA_TRANSACCION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_ADMINISTRADOR
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_ADMINISTRADOR" ON "ADMINISTRADOR" ("ID_ADMINISTRADOR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TRANSACCION
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_TRANSACCION" ON "TRANSACCION" ("ID_TRANSACCION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_TARJETA_CUENTA
--------------------------------------------------------

  CREATE INDEX "IDX_TARJETA_CUENTA" ON "TARJETA" ("ID_CUENTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_SUCURSAL
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_SUCURSAL" ON "SUCURSAL" ("ID_SUCURSAL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_ABONO
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_ABONO" ON "ABONO_EXTRAORDINARIO" ("ID_ABONO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_CLIENTE_EMAIL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UQ_CLIENTE_EMAIL" ON "CLIENTE" ("EMAIL_CLIENTE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_CUENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_CUENTA" ON "CUENTA" ("ID_CUENTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_TARJETA_NUMERO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UQ_TARJETA_NUMERO" ON "TARJETA" ("NUMERO_TARJETA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_CUENTA_SALDO_ACTIVA
--------------------------------------------------------

  CREATE INDEX "IDX_CUENTA_SALDO_ACTIVA" ON "CUENTA" (CASE "ESTADO_CUENTA" WHEN 'activa' THEN "SALDO_CUENTA" ELSE NULL END ) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_CLIENTE
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_CLIENTE" ON "CLIENTE" ("ID_CLIENTE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TARJETA
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_TARJETA" ON "TARJETA" ("ID_TARJETA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_TARJETA_ACTIVA_CUENTA
--------------------------------------------------------

  CREATE INDEX "IDX_TARJETA_ACTIVA_CUENTA" ON "TARJETA" (CASE "ESTADO_TARJETA" WHEN 'activa' THEN "ID_CUENTA" ELSE NULL END ) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_CLIENTE_NOMBRE_UPPER
--------------------------------------------------------

  CREATE INDEX "IDX_CLIENTE_NOMBRE_UPPER" ON "CLIENTE" (UPPER("NOMBRE_CLIENTE")) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_CUOTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "PK_CUOTA" ON "CUOTA" ("ID_CUOTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_CUENTA_CLIENTE
--------------------------------------------------------

  CREATE INDEX "IDX_CUENTA_CLIENTE" ON "CUENTA" ("ID_CLIENTE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_SUCURSAL_NOMBRE_UPPER
--------------------------------------------------------

  CREATE INDEX "IDX_SUCURSAL_NOMBRE_UPPER" ON "SUCURSAL" (UPPER("NOMBRE_SUCURSAL")) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_CAJERO_SUCURSAL
--------------------------------------------------------

  CREATE INDEX "IDX_CAJERO_SUCURSAL" ON "CAJERO" ("ID_SUCURSAL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_ABONO_TRX
--------------------------------------------------------

  CREATE UNIQUE INDEX "UQ_ABONO_TRX" ON "ABONO_EXTRAORDINARIO" ("ID_TRANSACCION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_PRESTAMO_SALDO_ACTIVO
--------------------------------------------------------

  CREATE INDEX "IDX_PRESTAMO_SALDO_ACTIVO" ON "PRESTAMO" (CASE "ESTADO_PRESTAMO" WHEN 'activo' THEN "SALDO_PRESTAMO" ELSE NULL END ) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUDITORIA_CAJERO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUDITORIA_CAJERO" 
BEFORE UPDATE ON CAJERO
FOR EACH ROW
BEGIN
    -- Registra cambios de estado
    IF :OLD.estado_cajero != :NEW.estado_cajero THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'CAJERO', TO_CHAR(:NEW.id_cajero), 'ESTADO_CAJERO',
            :OLD.estado_cajero, :NEW.estado_cajero, 'UPDATE'
        );
    END IF;

    -- Registra cambios significativos de dinero (mayores a 10000)
    IF ABS(:NEW.dinero_disponible_cajero - :OLD.dinero_disponible_cajero) > 10000 THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'CAJERO', TO_CHAR(:NEW.id_cajero), 'DINERO_DISPONIBLE_CAJERO',
            TO_CHAR(:OLD.dinero_disponible_cajero), TO_CHAR(:NEW.dinero_disponible_cajero), 'UPDATE'
        );
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUDITORIA_CAJERO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUDITORIA_CLIENTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUDITORIA_CLIENTE" 
BEFORE UPDATE ON CLIENTE
FOR EACH ROW
BEGIN
    -- Registra cambios en email
    IF :OLD.email_cliente != :NEW.email_cliente THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'CLIENTE', :NEW.id_cliente, 'EMAIL_CLIENTE',
            :OLD.email_cliente, :NEW.email_cliente, 'UPDATE'
        );
    END IF;

    -- Registra cambios en nombre
    IF :OLD.nombre_cliente != :NEW.nombre_cliente THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'CLIENTE', :NEW.id_cliente, 'NOMBRE_CLIENTE',
            :OLD.nombre_cliente, :NEW.nombre_cliente, 'UPDATE'
        );
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUDITORIA_CLIENTE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUDITORIA_CUENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUDITORIA_CUENTA" 
BEFORE UPDATE ON CUENTA
FOR EACH ROW
BEGIN
    -- Registra cambios de saldo significativos (mayores a 1000)
    IF ABS(:NEW.saldo_cuenta - :OLD.saldo_cuenta) > 1000 THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'CUENTA', TO_CHAR(:NEW.id_cuenta), 'SALDO_CUENTA',
            TO_CHAR(:OLD.saldo_cuenta), TO_CHAR(:NEW.saldo_cuenta), 'UPDATE'
        );
    END IF;

    -- Registra cambios de estado
    IF :OLD.estado_cuenta != :NEW.estado_cuenta THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'CUENTA', TO_CHAR(:NEW.id_cuenta), 'ESTADO_CUENTA',
            :OLD.estado_cuenta, :NEW.estado_cuenta, 'UPDATE'
        );
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUDITORIA_CUENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUDITORIA_PRESTAMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUDITORIA_PRESTAMO" 
BEFORE UPDATE ON PRESTAMO
FOR EACH ROW
BEGIN
    -- Registra cambios de estado de préstamo (importante para seguimiento)
    IF :OLD.estado_prestamo != :NEW.estado_prestamo THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'PRESTAMO', TO_CHAR(:NEW.id_prestamo), 'ESTADO_PRESTAMO',
            :OLD.estado_prestamo, :NEW.estado_prestamo, 'UPDATE'
        );
    END IF;

    -- Registra cambios significativos de saldo (mayores a 100000)
    IF ABS(:NEW.saldo_prestamo - :OLD.saldo_prestamo) > 100000 THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'PRESTAMO', TO_CHAR(:NEW.id_prestamo), 'SALDO_PRESTAMO',
            TO_CHAR(:OLD.saldo_prestamo), TO_CHAR(:NEW.saldo_prestamo), 'UPDATE'
        );
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUDITORIA_PRESTAMO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUDITORIA_TARJETA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUDITORIA_TARJETA" 
BEFORE UPDATE ON TARJETA
FOR EACH ROW
BEGIN
    -- Registra cambios de estado de tarjeta (importante para seguridad)
    IF :OLD.estado_tarjeta != :NEW.estado_tarjeta THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'TARJETA', TO_CHAR(:NEW.id_tarjeta), 'ESTADO_TARJETA',
            :OLD.estado_tarjeta, :NEW.estado_tarjeta, 'UPDATE'
        );
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUDITORIA_TARJETA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUDITORIA_TRANSACCION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUDITORIA_TRANSACCION" 
BEFORE INSERT ON TRANSACCION
FOR EACH ROW
BEGIN
    -- Valida que el monto sea positivo
    IF :NEW.monto_transaccion <= 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El monto de la transacción debe ser mayor a cero');
    END IF;

    -- Registra transacciones de alto monto (mayores a 50000) para auditoría
    IF :NEW.monto_transaccion > 50000 THEN
        INSERT INTO auditoria_cambios (
            TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
            VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
        ) VALUES (
            'TRANSACCION', TO_CHAR(:NEW.id_transaccion), 'MONTO_TRANSACCION',
            'NUEVA', TO_CHAR(:NEW.monto_transaccion), 'INSERT'
        );
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUDITORIA_TRANSACCION" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_ABONO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_ABONO" 
BEFORE INSERT ON ABONO_EXTRAORDINARIO
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_ABONO IS NULL THEN
        SELECT NVL(MAX(ID_ABONO),0) + 1 INTO V_ID FROM ABONO_EXTRAORDINARIO;
        :NEW.ID_ABONO := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_ABONO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_ADMINISTRADOR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_ADMINISTRADOR" 
BEFORE INSERT ON ADMINISTRADOR
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_ADMINISTRADOR IS NULL THEN
        SELECT NVL(MAX(ID_ADMINISTRADOR),0) + 1 INTO V_ID FROM ADMINISTRADOR;
        :NEW.ID_ADMINISTRADOR := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_ADMINISTRADOR" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_AUDITORIA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_AUDITORIA" 
BEFORE INSERT ON AUDITORIA_CAMBIOS
FOR EACH ROW
DECLARE
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_AUDITORIA IS NULL THEN
        SELECT NVL(MAX(ID_AUDITORIA), 0) + 1 INTO V_ID FROM AUDITORIA_CAMBIOS;
        :NEW.ID_AUDITORIA := V_ID;
    END IF;
    :NEW.USUARIO_ORACLE := USER;
END;

/
ALTER TRIGGER "TRIGGER_AUTO_ID_AUDITORIA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_CAJERO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_CAJERO" 
BEFORE INSERT ON CAJERO
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_CAJERO IS NULL THEN
        SELECT NVL(MAX(ID_CAJERO),0) + 1 INTO V_ID FROM CAJERO;
        :NEW.ID_CAJERO := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_CAJERO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_CUENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_CUENTA" 
BEFORE INSERT ON CUENTA
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_CUENTA IS NULL THEN
        SELECT NVL(MAX(ID_CUENTA),0) + 1 INTO V_ID FROM CUENTA;
        :NEW.ID_CUENTA := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_CUENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_CUOTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_CUOTA" 
BEFORE INSERT ON CUOTA
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_CUOTA IS NULL THEN
        SELECT NVL(MAX(ID_CUOTA),0) + 1 INTO V_ID FROM CUOTA;
        :NEW.ID_CUOTA := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_CUOTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_PRESTAMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_PRESTAMO" 
BEFORE INSERT ON PRESTAMO
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_PRESTAMO IS NULL THEN
        SELECT NVL(MAX(ID_PRESTAMO),0) + 1 INTO V_ID FROM PRESTAMO;
        :NEW.ID_PRESTAMO := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_PRESTAMO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_SUCURSAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_SUCURSAL" 
BEFORE INSERT ON SUCURSAL
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_SUCURSAL IS NULL THEN
        SELECT NVL(MAX(ID_SUCURSAL),0) + 1 INTO V_ID FROM SUCURSAL;
        :NEW.ID_SUCURSAL := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_SUCURSAL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_TARJETA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_TARJETA" 
BEFORE INSERT ON TARJETA
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_TARJETA IS NULL THEN
        SELECT NVL(MAX(ID_TARJETA),0) + 1 INTO V_ID FROM TARJETA;
        :NEW.ID_TARJETA := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_TARJETA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_AUTO_ID_TRANSACCION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_AUTO_ID_TRANSACCION" 
BEFORE INSERT ON TRANSACCION
FOR EACH ROW
DECLARE 
    V_ID NUMBER;
BEGIN
    IF :NEW.ID_TRANSACCION IS NULL THEN
        SELECT NVL(MAX(ID_TRANSACCION),0) + 1 INTO V_ID FROM TRANSACCION;
        :NEW.ID_TRANSACCION := V_ID;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_AUTO_ID_TRANSACCION" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_COMPOUND_CAJERO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_COMPOUND_CAJERO" 
FOR UPDATE ON CAJERO
COMPOUND TRIGGER
    TYPE t_cajeros IS TABLE OF NUMBER;
    v_cajeros_modificados t_cajeros := t_cajeros();
    v_total_dinero_movido NUMBER := 0;
    v_cajeros_con_cambio NUMBER := 0;

    BEFORE STATEMENT IS
    BEGIN
        v_cajeros_modificados.DELETE;
        v_total_dinero_movido := 0;
        v_cajeros_con_cambio := 0;
    END BEFORE STATEMENT;

    AFTER EACH ROW IS
    BEGIN
        IF :OLD.dinero_disponible_cajero != :NEW.dinero_disponible_cajero THEN
            v_cajeros_modificados.EXTEND;
            v_cajeros_modificados(v_cajeros_modificados.COUNT) := :NEW.id_cajero;
            v_total_dinero_movido := v_total_dinero_movido + ABS(:NEW.dinero_disponible_cajero - :OLD.dinero_disponible_cajero);
            v_cajeros_con_cambio := v_cajeros_con_cambio + 1;
        END IF;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        -- Registra estadísticas de la operación masiva
        IF v_cajeros_modificados.COUNT > 0 THEN
            INSERT INTO auditoria_cambios (
                TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
                VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
            ) VALUES (
                'CAJERO', 'MASIVO', 'ESTADISTICAS',
                'Cajeros con cambio: ' || v_cajeros_con_cambio,
                'Dinero total movido: ' || TO_CHAR(v_total_dinero_movido),
                'BATCH'
            );
        END IF;
    END AFTER STATEMENT;
END;


/
ALTER TRIGGER "TRIGGER_COMPOUND_CAJERO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_COMPOUND_CLIENTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_COMPOUND_CLIENTE" 
FOR INSERT OR UPDATE OR DELETE ON CLIENTE
COMPOUND TRIGGER
    TYPE t_ids IS TABLE OF VARCHAR2(10);
    v_ids_modificados t_ids := t_ids();
    v_total_insertados NUMBER := 0;
    v_total_actualizados NUMBER := 0;
    v_total_eliminados NUMBER := 0;
    v_valor_anterior VARCHAR2(4000);
    v_valor_nuevo VARCHAR2(4000);

    BEFORE STATEMENT IS
    BEGIN
        v_ids_modificados.DELETE;
        v_total_insertados := 0;
        v_total_actualizados := 0;
        v_total_eliminados := 0;
    END BEFORE STATEMENT;

    AFTER EACH ROW IS
    BEGIN
        IF INSERTING THEN
            v_ids_modificados.EXTEND;
            v_ids_modificados(v_ids_modificados.COUNT) := :NEW.id_cliente;
            v_total_insertados := v_total_insertados + 1;
        ELSIF UPDATING THEN
            v_ids_modificados.EXTEND;
            v_ids_modificados(v_ids_modificados.COUNT) := :NEW.id_cliente;
            v_total_actualizados := v_total_actualizados + 1;
        ELSIF DELETING THEN
            v_ids_modificados.EXTEND;
            v_ids_modificados(v_ids_modificados.COUNT) := :OLD.id_cliente;
            v_total_eliminados := v_total_eliminados + 1;
        END IF;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        -- Registra estadísticas de la operación masiva
        IF v_ids_modificados.COUNT > 0 THEN
            v_valor_anterior := 'Total procesados: ' || TO_CHAR(v_ids_modificados.COUNT);
            v_valor_nuevo := 'Ins: ' || TO_CHAR(v_total_insertados) || ' Upd: ' || TO_CHAR(v_total_actualizados) || ' Del: ' || TO_CHAR(v_total_eliminados);

            INSERT INTO auditoria_cambios (
                TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
                VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
            ) VALUES (
                'CLIENTE', 'MASIVO', 'ESTADISTICAS',
                v_valor_anterior,
                v_valor_nuevo,
                'BATCH'
            );
        END IF;
    END AFTER STATEMENT;
END;


/
ALTER TRIGGER "TRIGGER_COMPOUND_CLIENTE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_COMPOUND_CUENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_COMPOUND_CUENTA" 
FOR INSERT OR UPDATE ON CUENTA
COMPOUND TRIGGER
    TYPE t_cuentas IS TABLE OF NUMBER;
    v_cuentas_modificadas t_cuentas := t_cuentas();
    v_total_monto_movido NUMBER := 0;
    v_total_cuentas NUMBER := 0;

    BEFORE STATEMENT IS
    BEGIN
        v_cuentas_modificadas.DELETE;
        v_total_monto_movido := 0;
        v_total_cuentas := 0;
    END BEFORE STATEMENT;

    AFTER EACH ROW IS
    BEGIN
        v_cuentas_modificadas.EXTEND;
        v_cuentas_modificadas(v_cuentas_modificadas.COUNT) := :NEW.id_cuenta;

        -- Calcula el monto total movido en esta operación
        IF UPDATING AND :OLD.saldo_cuenta IS NOT NULL AND :NEW.saldo_cuenta IS NOT NULL THEN
            v_total_monto_movido := v_total_monto_movido + ABS(:NEW.saldo_cuenta - :OLD.saldo_cuenta);
        END IF;

        v_total_cuentas := v_total_cuentas + 1;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        -- Registra estadísticas de la operación masiva
        IF v_cuentas_modificadas.COUNT > 0 THEN
            INSERT INTO auditoria_cambios (
                TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
                VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
            ) VALUES (
                'CUENTA', 'MASIVO', 'ESTADISTICAS',
                'Total cuentas: ' || v_total_cuentas,
                'Monto total movido: ' || TO_CHAR(v_total_monto_movido),
                'BATCH'
            );
        END IF;
    END AFTER STATEMENT;
END;


/
ALTER TRIGGER "TRIGGER_COMPOUND_CUENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_COMPOUND_PRESTAMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_COMPOUND_PRESTAMO" 
FOR UPDATE ON PRESTAMO
COMPOUND TRIGGER
    TYPE t_prestamos IS TABLE OF NUMBER;
    v_prestamos_modificados t_prestamos := t_prestamos();
    v_total_saldo_reducido NUMBER := 0;
    v_prestamos_con_cambio NUMBER := 0;
    v_prestamos_finalizados NUMBER := 0;

    BEFORE STATEMENT IS
    BEGIN
        v_prestamos_modificados.DELETE;
        v_total_saldo_reducido := 0;
        v_prestamos_con_cambio := 0;
        v_prestamos_finalizados := 0;
    END BEFORE STATEMENT;

    AFTER EACH ROW IS
    BEGIN
        IF :OLD.saldo_prestamo != :NEW.saldo_prestamo THEN
            v_prestamos_modificados.EXTEND;
            v_prestamos_modificados(v_prestamos_modificados.COUNT) := :NEW.id_prestamo;
            v_total_saldo_reducido := v_total_saldo_reducido + (:OLD.saldo_prestamo - :NEW.saldo_prestamo);
            v_prestamos_con_cambio := v_prestamos_con_cambio + 1;
        END IF;

        -- Detecta préstamos que fueron finalizados
        IF :OLD.estado_prestamo != 'finalizado' AND :NEW.estado_prestamo = 'finalizado' THEN
            v_prestamos_finalizados := v_prestamos_finalizados + 1;
        END IF;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        -- Registra estadísticas de la operación masiva
        IF v_prestamos_modificados.COUNT > 0 THEN
            INSERT INTO auditoria_cambios (
                TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
                VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
            ) VALUES (
                'PRESTAMO', 'MASIVO', 'ESTADISTICAS',
                'Préstamos con cambio: ' || v_prestamos_con_cambio || ', Finalizados: ' || v_prestamos_finalizados,
                'Saldo total reducido: ' || TO_CHAR(v_total_saldo_reducido),
                'BATCH'
            );
        END IF;
    END AFTER STATEMENT;
END;


/
ALTER TRIGGER "TRIGGER_COMPOUND_PRESTAMO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_COMPOUND_TARJETA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_COMPOUND_TARJETA" 
FOR INSERT OR UPDATE ON TARJETA
COMPOUND TRIGGER
    TYPE t_tarjetas IS TABLE OF NUMBER;
    v_tarjetas_modificadas t_tarjetas := t_tarjetas();
    v_total_insertadas NUMBER := 0;
    v_total_actualizadas NUMBER := 0;
    v_tarjetas_bloqueadas NUMBER := 0;

    BEFORE STATEMENT IS
    BEGIN
        v_tarjetas_modificadas.DELETE;
        v_total_insertadas := 0;
        v_total_actualizadas := 0;
        v_tarjetas_bloqueadas := 0;
    END BEFORE STATEMENT;

    AFTER EACH ROW IS
    BEGIN
        v_tarjetas_modificadas.EXTEND;
        v_tarjetas_modificadas(v_tarjetas_modificadas.COUNT) := :NEW.id_tarjeta;

        IF INSERTING THEN
            v_total_insertadas := v_total_insertadas + 1;
        ELSIF UPDATING THEN
            v_total_actualizadas := v_total_actualizadas + 1;
            -- Cuenta tarjetas que fueron bloqueadas
            IF :OLD.estado_tarjeta != 'bloqueada' AND :NEW.estado_tarjeta = 'bloqueada' THEN
                v_tarjetas_bloqueadas := v_tarjetas_bloqueadas + 1;
            END IF;
        END IF;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        -- Registra estadísticas de la operación masiva
        IF v_tarjetas_modificadas.COUNT > 0 THEN
            INSERT INTO auditoria_cambios (
                TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
                VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
            ) VALUES (
                'TARJETA', 'MASIVO', 'ESTADISTICAS',
                'Ins: ' || v_total_insertadas || ' Upd: ' || v_total_actualizadas,
                'Bloqueadas: ' || v_tarjetas_bloqueadas,
                'BATCH'
            );
        END IF;
    END AFTER STATEMENT;
END;


/
ALTER TRIGGER "TRIGGER_COMPOUND_TARJETA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_COMPOUND_TRANSACCION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_COMPOUND_TRANSACCION" 
FOR INSERT ON TRANSACCION
COMPOUND TRIGGER
    TYPE t_transacciones IS TABLE OF NUMBER;
    v_transacciones_modificadas t_transacciones := t_transacciones();
    v_total_monto NUMBER := 0;
    v_transacciones_cuenta NUMBER := 0;
    v_transacciones_cajero NUMBER := 0;
    v_valor_anterior VARCHAR2(4000);
    v_valor_nuevo VARCHAR2(4000);

    BEFORE STATEMENT IS
    BEGIN
        v_transacciones_modificadas.DELETE;
        v_total_monto := 0;
        v_transacciones_cuenta := 0;
        v_transacciones_cajero := 0;
    END BEFORE STATEMENT;

    AFTER EACH ROW IS
    BEGIN
        v_transacciones_modificadas.EXTEND;
        v_transacciones_modificadas(v_transacciones_modificadas.COUNT) := :NEW.id_transaccion;
        v_total_monto := v_total_monto + :NEW.monto_transaccion;

        -- Clasifica por tipo de transacción
        IF :NEW.tipo_transaccion = 'cuenta' THEN
            v_transacciones_cuenta := v_transacciones_cuenta + 1;
        ELSIF :NEW.tipo_transaccion = 'cajero' THEN
            v_transacciones_cajero := v_transacciones_cajero + 1;
        END IF;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        -- Registra estadísticas de la operación masiva
        IF v_transacciones_modificadas.COUNT > 0 THEN
            v_valor_anterior := 'Total: ' || TO_CHAR(v_transacciones_modificadas.COUNT) || ' (Cuenta: ' || TO_CHAR(v_transacciones_cuenta) || ', Cajero: ' || TO_CHAR(v_transacciones_cajero) || ')';
            v_valor_nuevo := 'Monto total: ' || TO_CHAR(v_total_monto);

            INSERT INTO auditoria_cambios (
                TABLA_AFECTADA, ID_REGISTRO, CAMPO_MODIFICADO,
                VALOR_ANTERIOR, VALOR_NUEVO, TIPO_OPERACION
            ) VALUES (
                'TRANSACCION', 'MASIVO', 'ESTADISTICAS',
                v_valor_anterior,
                v_valor_nuevo,
                'BATCH'
            );
        END IF;
    END AFTER STATEMENT;
END;


/
ALTER TRIGGER "TRIGGER_COMPOUND_TRANSACCION" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_INSTEAD_OF_CAJEROS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_INSTEAD_OF_CAJEROS" 
INSTEAD OF UPDATE ON vw_cajeros_completos
FOR EACH ROW
BEGIN
    UPDATE cajero SET
        dinero_disponible_cajero = :NEW.dinero_disponible_cajero,
        estado_cajero = :NEW.estado_cajero
    WHERE id_cajero = :NEW.id_cajero;

    UPDATE sucursal SET
        nombre_sucursal = :NEW.nombre_sucursal,
        direccion_sucursal = :NEW.direccion_sucursal
    WHERE id_sucursal = :NEW.id_sucursal;
END;


/
ALTER TRIGGER "TRIGGER_INSTEAD_OF_CAJEROS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_INSTEAD_OF_CLIENTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_INSTEAD_OF_CLIENTES" 
INSTEAD OF INSERT OR UPDATE ON vw_clientes_completos
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO cliente (
            id_cliente, nombre_cliente, email_cliente, 
            telefono_cliente, cedula_cliente, estado_cliente, 
            fecha_registro_cliente
        ) VALUES (
            :NEW.id_cliente, :NEW.nombre_cliente, :NEW.email_cliente,
            :NEW.telefono_cliente, :NEW.cedula_cliente, :NEW.estado_cliente,
            SYSTIMESTAMP
        );
    ELSIF UPDATING THEN
        UPDATE cliente SET
            nombre_cliente = :NEW.nombre_cliente,
            email_cliente = :NEW.email_cliente,
            telefono_cliente = :NEW.telefono_cliente,
            estado_cliente = :NEW.estado_cliente
        WHERE id_cliente = :NEW.id_cliente;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_INSTEAD_OF_CLIENTES" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_INSTEAD_OF_CUENTAS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_INSTEAD_OF_CUENTAS" 
INSTEAD OF INSERT OR UPDATE ON vw_cuentas_completas
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO cuenta (
            id_cuenta, id_cliente, saldo_cuenta, 
            estado_cuenta, fecha_creacion_cuenta
        ) VALUES (
            :NEW.id_cuenta, :NEW.id_cliente, :NEW.saldo_cuenta,
            :NEW.estado_cuenta, SYSTIMESTAMP
        );
    ELSIF UPDATING THEN
        UPDATE cuenta SET
            saldo_cuenta = :NEW.saldo_cuenta,
            estado_cuenta = :NEW.estado_cuenta
        WHERE id_cuenta = :NEW.id_cuenta;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_INSTEAD_OF_CUENTAS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_INSTEAD_OF_PRESTAMOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_INSTEAD_OF_PRESTAMOS" 
INSTEAD OF INSERT OR UPDATE ON vw_prestamos_completos
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        -- Insertar préstamo básico
        INSERT INTO prestamo (
            id_prestamo, id_cuenta, monto_prestamo, saldo_prestamo,
            estado_prestamo, fecha_inicio_prestamo, id_sucursal
        ) VALUES (
            :NEW.id_prestamo, :NEW.id_cuenta, :NEW.monto_prestamo,
            :NEW.saldo_prestamo, :NEW.estado_prestamo, SYSTIMESTAMP, NULL
        );
    ELSIF UPDATING THEN
        -- Actualizar préstamo
        UPDATE prestamo SET
            monto_prestamo = :NEW.monto_prestamo,
            saldo_prestamo = :NEW.saldo_prestamo,
            estado_prestamo = :NEW.estado_prestamo
        WHERE id_prestamo = :NEW.id_prestamo;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_INSTEAD_OF_PRESTAMOS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_INSTEAD_OF_TARJETAS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_INSTEAD_OF_TARJETAS" 
INSTEAD OF INSERT OR UPDATE ON vw_tarjetas_completas
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO tarjeta (
            id_tarjeta, id_cuenta, numero_tarjeta, 
            estado_tarjeta, fecha_emision_tarjeta, fecha_vencimiento_tarjeta
        ) VALUES (
            :NEW.id_tarjeta, :NEW.id_cuenta, :NEW.numero_tarjeta,
            :NEW.estado_tarjeta, SYSTIMESTAMP, ADD_MONTHS(SYSTIMESTAMP, 48)
        );

        IF :NEW.tipo_tarjeta = 'CREDITO' THEN
            INSERT INTO tarjeta_credito (id_tarjeta, limite_credito)
            VALUES (:NEW.id_tarjeta, :NEW.limite);
        ELSIF :NEW.tipo_tarjeta = 'DEBITO' THEN
            INSERT INTO tarjeta_debito (id_tarjeta, limite_retiro_debito)
            VALUES (:NEW.id_tarjeta, :NEW.limite);
        END IF;
    ELSIF UPDATING THEN
        UPDATE tarjeta SET
            estado_tarjeta = :NEW.estado_tarjeta
        WHERE id_tarjeta = :NEW.id_tarjeta;
    END IF;
END;


/
ALTER TRIGGER "TRIGGER_INSTEAD_OF_TARJETAS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRIGGER_INSTEAD_OF_TRANSACCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRIGGER_INSTEAD_OF_TRANSACCIONES" 
INSTEAD OF INSERT ON vw_transacciones_completas
FOR EACH ROW
BEGIN
    INSERT INTO transaccion (
        id_transaccion, id_cuenta_origen, id_cuenta_destino,
        monto_transaccion, fecha_transaccion, estado_transaccion,
        tipo_transaccion
    ) VALUES (
        :NEW.id_transaccion, :NEW.cuenta_origen_id, :NEW.cuenta_destino_id,
        :NEW.monto_transaccion, SYSTIMESTAMP, :NEW.estado_transaccion,
        :NEW.tipo_transaccion
    );
END;


/
ALTER TRIGGER "TRIGGER_INSTEAD_OF_TRANSACCIONES" ENABLE;
--------------------------------------------------------
--  DDL for Package PKG_ADMINISTRADOR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKG_ADMINISTRADOR" AS

  -- Devuelve ID del admin si login es correcto, sino NULL
  FUNCTION function_login_admin(
    p_email       IN VARCHAR2,
    p_contrasena  IN VARCHAR2
  ) RETURN NUMBER;

END pkg_administrador;


/
--------------------------------------------------------
--  DDL for Package PKGC_ABONOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKGC_ABONOS" AS

    -- Registrar abono extraordinario
    PROCEDURE procedure_registrar_abono(
        p_id_prestamo     IN NUMBER,
        p_monto_abono     IN NUMBER,
        p_tipo_abono      IN VARCHAR2,
        p_id_cuenta       IN NUMBER,
        o_id_abono        OUT NUMBER,
        o_id_transaccion  OUT NUMBER
    );

    -- Listar abonos de un préstamo
    PROCEDURE procedure_listar_abonos(
        p_id_prestamo IN NUMBER,
        o_cursor      OUT SYS_REFCURSOR
    );

END pkgc_abonos;


/
--------------------------------------------------------
--  DDL for Package PKGC_CAJEROS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKGC_CAJEROS" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_cajero IS TABLE OF NUMBER;

    -- ========== REGISTROS ==========
    TYPE t_info_cajero IS RECORD (
        id_cajero NUMBER,
        id_sucursal NUMBER,
        dinero_disponible NUMBER,
        estado VARCHAR2(20)
    );

    TYPE t_lista_cajeros IS TABLE OF t_info_cajero;

    PROCEDURE procedure_crear_cajero(
        p_id_sucursal IN NUMBER, p_id_admin IN NUMBER,
        p_dinero_inicial IN NUMBER, o_id_cajero OUT NUMBER
    );
    PROCEDURE procedure_cambiar_estado_cajero(p_id_cajero IN NUMBER, p_estado IN VARCHAR2);
    PROCEDURE procedure_recargar_cajero(p_id_cajero IN NUMBER, p_monto IN NUMBER);
    PROCEDURE procedure_descontar_cajero(p_id_cajero IN NUMBER, p_monto IN NUMBER);
    PROCEDURE procedure_listar_cajeros(p_id_sucursal IN NUMBER, o_cursor OUT SYS_REFCURSOR);

    -- ========== NUEVO PROCEDIMIENTO ==========
    PROCEDURE procedure_obtener_cajeros_por_ids(
        p_ids IN t_lista_ids_cajero,
        p_resultado OUT t_lista_cajeros
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_cajeros_activos(
        o_resultado OUT t_lista_cajeros
    );
END pkgc_cajeros;


/
--------------------------------------------------------
--  DDL for Package PKGC_CUOTAS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKGC_CUOTAS" AS

    -- Generar todas las cuotas de un préstamo activo
    PROCEDURE procedure_generar_cuotas(
        p_id_prestamo IN NUMBER
    );

    -- Pagar una cuota
    PROCEDURE procedure_pagar_cuota(
        p_id_cuota        IN NUMBER,
        p_id_cuenta       IN NUMBER,
        o_id_transaccion  OUT NUMBER
    );

    -- Listar cuotas de un préstamo
    PROCEDURE procedure_listar_cuotas(
        p_id_prestamo IN NUMBER,
        o_cursor      OUT SYS_REFCURSOR
    );

END pkgc_cuotas;


/
--------------------------------------------------------
--  DDL for Package PKG_CLIENTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKG_CLIENTES" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_cliente IS TABLE OF VARCHAR2(10);
    TYPE t_lista_nombres IS TABLE OF VARCHAR2(120);

    -- ========== REGISTROS ==========
    TYPE t_info_cliente IS RECORD (
        id_cliente VARCHAR2(10),
        nombre_cliente VARCHAR2(120),
        email_cliente VARCHAR2(120),
        telefono_cliente VARCHAR2(30)
    );

    TYPE t_lista_clientes IS TABLE OF t_info_cliente;

    -- Procedimientos y funciones con prefijos completos
    PROCEDURE procedure_obtener_solicitudes(result OUT SYS_REFCURSOR);
    FUNCTION function_generar_id_cliente RETURN VARCHAR2;
    FUNCTION function_existe_cliente(p_id_cliente IN VARCHAR2) RETURN BOOLEAN;
    FUNCTION function_email_disponible(p_email IN VARCHAR2, p_excluir_id IN VARCHAR2 DEFAULT NULL) RETURN BOOLEAN;
    PROCEDURE procedure_crear_cliente(
        p_nombre_cliente IN VARCHAR2,
        p_email_cliente IN VARCHAR2,
        p_telefono_cliente IN VARCHAR2,
        p_cedula_cliente IN NUMBER,
        p_estado_cliente IN VARCHAR2 DEFAULT 'ACTIVO',
        o_id_cliente OUT VARCHAR2
    );
    PROCEDURE procedure_actualizar_datos_cliente(
        p_id_cliente IN VARCHAR2,
        p_nombre_cliente IN VARCHAR2,
        p_email_cliente IN VARCHAR2,
        p_telefono_cliente IN VARCHAR2,
        p_cedula_cliente IN NUMBER
    );
    PROCEDURE procedure_actualizar_correo_cliente(p_id_cliente IN VARCHAR2, p_email_cliente IN VARCHAR2);
    PROCEDURE procedure_actualizar_nombre_cliente(p_id_cliente IN VARCHAR2, p_nombre_cliente IN VARCHAR2);
    PROCEDURE procedure_actualizar_telefono_cliente(p_id_cliente IN VARCHAR2, p_telefono_cliente IN VARCHAR2);
    PROCEDURE procedure_actualizar_cedula_cliente(p_id_cliente IN VARCHAR2, p_cedula_cliente IN NUMBER);
    PROCEDURE procedure_eliminar_cliente(p_id_cliente IN VARCHAR2);
    PROCEDURE procedure_crear_cuenta_cliente(p_id_cliente IN VARCHAR2, p_id_administrador IN NUMBER, o_id_cuenta OUT NUMBER);

    -- ========== NUEVOS PROCEDIMIENTOS CON COLECCIONES Y REGISTROS ==========
    PROCEDURE procedure_obtener_clientes_por_ids(
        p_ids IN t_lista_ids_cliente,
        p_resultado OUT t_lista_clientes
    );

    PROCEDURE procedure_procesar_clientes_masivos(
        p_clientes IN t_lista_clientes,
        o_resultado OUT NUMBER
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_clientes_activos(
        o_resultado OUT t_lista_clientes
    );
END pkg_clientes;


/
--------------------------------------------------------
--  DDL for Package PKGC_PRESTAMOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKGC_PRESTAMOS" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_prestamo IS TABLE OF NUMBER;

    -- ========== REGISTROS ==========
    TYPE t_info_prestamo IS RECORD (
        id_prestamo NUMBER,
        id_cuenta NUMBER,
        monto_prestamo NUMBER,
        saldo_prestamo NUMBER,
        estado_prestamo VARCHAR2(12)
    );

    TYPE t_lista_prestamos IS TABLE OF t_info_prestamo;

    PROCEDURE procedure_solicitar_prestamo(
        p_id_cuenta IN NUMBER, p_id_sucursal IN NUMBER,
        p_monto IN NUMBER, p_fecha_inicio IN DATE, p_fecha_fin IN DATE,
        o_id_prestamo OUT NUMBER
    );
    PROCEDURE procedure_listar_solicitudes(p_id_sucursal IN NUMBER, o_cursor OUT SYS_REFCURSOR);
    PROCEDURE procedure_aceptar(p_id_prestamo IN NUMBER);
    PROCEDURE procedure_rechazar(p_id_prestamo IN NUMBER);
    PROCEDURE procedure_actualizar_saldo(p_id_prestamo IN NUMBER);

    -- ========== NUEVO PROCEDIMIENTO ==========
    PROCEDURE procedure_obtener_prestamos_por_ids(
        p_ids IN t_lista_ids_prestamo,
        p_resultado OUT t_lista_prestamos
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_prestamos_activos(
        o_resultado OUT t_lista_prestamos
    );
END pkgc_prestamos;


/
--------------------------------------------------------
--  DDL for Package PKGC_TARJETAS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKGC_TARJETAS" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_tarjeta IS TABLE OF NUMBER;

    -- ========== REGISTROS ==========
    TYPE t_info_tarjeta IS RECORD (
        id_tarjeta NUMBER,
        id_cuenta NUMBER,
        numero_tarjeta VARCHAR2(25),
        estado_tarjeta VARCHAR2(10),
        tipo_tarjeta VARCHAR2(10)
    );

    TYPE t_lista_tarjetas IS TABLE OF t_info_tarjeta;

    PROCEDURE procedure_crear_tarjeta_debito(
        p_id_cuenta IN NUMBER, p_limite_retiro IN NUMBER, o_id_tarjeta OUT NUMBER
    );
    PROCEDURE procedure_crear_tarjeta_credito(
        p_id_cuenta IN NUMBER, p_limite_credito IN NUMBER, p_tasa_interes IN NUMBER,
        p_cuota_manejo IN NUMBER, p_fecha_corte IN NUMBER, o_id_tarjeta OUT NUMBER
    );
    PROCEDURE procedure_cambiar_estado_tarjeta(p_id_tarjeta IN NUMBER, p_estado IN VARCHAR2);
    PROCEDURE procedure_listar_tarjetas(p_id_cuenta IN NUMBER, o_cursor OUT SYS_REFCURSOR);

    -- ========== NUEVO PROCEDIMIENTO ==========
    PROCEDURE procedure_obtener_tarjetas_por_ids(
        p_ids IN t_lista_ids_tarjeta,
        p_resultado OUT t_lista_tarjetas
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_tarjetas_activas(
        o_resultado OUT t_lista_tarjetas
    );
END pkgc_tarjetas;


/
--------------------------------------------------------
--  DDL for Package PKGC_TRANSACCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKGC_TRANSACCIONES" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_transaccion IS TABLE OF NUMBER;

    -- ========== REGISTROS ==========
    TYPE t_info_transaccion IS RECORD (
        id_transaccion NUMBER,
        monto_transaccion NUMBER,
        fecha_transaccion TIMESTAMP,
        estado_transaccion VARCHAR2(12),
        tipo_transaccion VARCHAR2(20)
    );

    TYPE t_lista_transacciones IS TABLE OF t_info_transaccion;

    PROCEDURE procedure_transferencia(
        p_cuenta_origen IN NUMBER, p_cuenta_destino IN NUMBER,
        p_monto IN NUMBER, o_id_transaccion OUT NUMBER
    );
    PROCEDURE procedure_retiro_debito(
        p_id_tarjeta IN NUMBER, p_id_cajero IN NUMBER,
        p_monto IN NUMBER, o_id_transaccion OUT NUMBER
    );
    PROCEDURE procedure_retiro_credito(
        p_id_tarjeta IN NUMBER, p_id_cajero IN NUMBER,
        p_monto IN NUMBER, o_id_transaccion OUT NUMBER
    );
    PROCEDURE procedure_historial_cuenta(p_id_cuenta IN NUMBER, o_cursor OUT SYS_REFCURSOR);
    PROCEDURE procedure_historial_cajero(p_id_cuenta IN NUMBER, o_cursor OUT SYS_REFCURSOR);

    -- ========== NUEVO PROCEDIMIENTO ==========
    PROCEDURE procedure_obtener_transacciones_por_ids(
        p_ids IN t_lista_ids_transaccion,
        p_resultado OUT t_lista_transacciones
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_transacciones_hoy(
        o_resultado OUT t_lista_transacciones
    );
END pkgc_transacciones;


/
--------------------------------------------------------
--  DDL for Package PKG_CUENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKG_CUENTA" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_cuenta IS TABLE OF NUMBER;

    -- ========== REGISTROS ==========
    TYPE t_info_cuenta IS RECORD (
        id_cuenta NUMBER,
        id_cliente VARCHAR2(10),
        saldo_cuenta NUMBER,
        estado_cuenta VARCHAR2(10)
    );

    TYPE t_lista_cuentas IS TABLE OF t_info_cuenta;

    -- Procedimientos y funciones con prefijos completos
    FUNCTION function_login_cuenta(p_email IN VARCHAR2, p_contrasena IN VARCHAR2) RETURN NUMBER;
    FUNCTION function_generar_id_cuenta RETURN NUMBER;
    PROCEDURE procedure_crear_cuenta(p_id_cliente IN VARCHAR2, p_id_administrador IN NUMBER, o_id_cuenta OUT NUMBER);
    PROCEDURE procedure_consultar_cuentas_por_cliente(p_id_cliente IN VARCHAR2, result OUT SYS_REFCURSOR);
    PROCEDURE procedure_consultar_cuentas_por_id(p_id_cuenta IN NUMBER, result OUT SYS_REFCURSOR);
    PROCEDURE procedure_actualizar_cuenta(p_id_cuenta IN NUMBER, p_saldo IN NUMBER DEFAULT NULL, p_estado IN VARCHAR2 DEFAULT NULL);
    PROCEDURE procedure_cambiar_saldo(p_id_cuenta IN NUMBER, p_monto IN NUMBER);
    PROCEDURE procedure_eliminar_cuenta(p_id_cuenta IN NUMBER);
    PROCEDURE procedure_cambiar_contrasena(p_id_cuenta IN NUMBER, p_nueva_contrasena IN VARCHAR2);

    -- ========== NUEVOS PROCEDIMIENTOS ==========
    PROCEDURE procedure_obtener_cuentas_por_ids(
        p_ids IN t_lista_ids_cuenta,
        p_resultado OUT t_lista_cuentas
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_cuentas_activas(
        o_resultado OUT t_lista_cuentas
    );
END pkg_cuenta;


/
--------------------------------------------------------
--  DDL for Package PKG_SUCURSAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PKG_SUCURSAL" AS
    -- ========== COLECCIONES ==========
    TYPE t_lista_ids_sucursal IS TABLE OF NUMBER;

    -- ========== REGISTROS ==========
    TYPE t_info_sucursal IS RECORD (
        id_sucursal NUMBER,
        nombre_sucursal VARCHAR2(200),
        direccion_sucursal VARCHAR2(200),
        telefono_sucursal VARCHAR2(50),
        estado_sucursal VARCHAR2(20),
        id_administrador NUMBER
    );

    TYPE t_lista_sucursales IS TABLE OF t_info_sucursal;

    PROCEDURE procedure_listar_sucursales(o_cursor OUT SYS_REFCURSOR);
    FUNCTION function_crear_sucursal(
        p_nombre      IN VARCHAR2,
        p_direccion   IN VARCHAR2,
        p_telefono    IN VARCHAR2,
        p_id_admin    IN NUMBER
    ) RETURN NUMBER;
    PROCEDURE procedure_editar_estado(p_id_sucursal IN NUMBER, p_estado IN VARCHAR2);
    PROCEDURE procedure_eliminar_sucursal(p_id_sucursal IN NUMBER);

    -- ========== NUEVO PROCEDIMIENTO ==========
    PROCEDURE procedure_obtener_sucursales_por_ids(
        p_ids IN t_lista_ids_sucursal,
        p_resultado OUT t_lista_sucursales
    );

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_sucursales_abiertas(
        o_resultado OUT t_lista_sucursales
    );
END pkg_sucursal;


/
--------------------------------------------------------
--  DDL for Package Body PKG_ADMINISTRADOR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKG_ADMINISTRADOR" AS

  FUNCTION function_login_admin(
    p_email       IN VARCHAR2,
    p_contrasena  IN VARCHAR2
  ) RETURN NUMBER IS
    v_id NUMBER;
  BEGIN
    -- ✅ CORREGIDO: id_administrador (antes decía id_adminISTRADOR)
    SELECT id_administrador
    INTO v_id
    FROM administrador
    WHERE UPPER(email_administrador) = UPPER(p_email)
      AND contrasena_administrador = p_contrasena;

    RETURN v_id;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
  END function_login_admin;

END pkg_administrador;


/
--------------------------------------------------------
--  DDL for Package Body PKGC_ABONOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKGC_ABONOS" AS

    FUNCTION function_generar_id_abono RETURN NUMBER IS
        v_id NUMBER;
    BEGIN
        SELECT NVL(MAX(id_abono),0)+1
        INTO v_id
        FROM abono_extraordinario;
        RETURN v_id;
    END function_generar_id_abono;

    --------------------------------------------------------------------
    -- Registrar ABONO EXTRAORDINARIO
    --------------------------------------------------------------------
    PROCEDURE procedure_registrar_abono(
        p_id_prestamo     IN NUMBER,
        p_monto_abono     IN NUMBER,
        p_tipo_abono      IN VARCHAR2,
        p_id_cuenta       IN NUMBER,
        o_id_abono        OUT NUMBER,
        o_id_transaccion  OUT NUMBER
    )
    IS
        v_saldo_prestamo  NUMBER;
        v_estado          VARCHAR2(20);
        v_saldo_cuenta    NUMBER;
        v_id_transaccion  NUMBER;
        v_id_abono        NUMBER;
        v_existe          NUMBER;
    BEGIN
        -- Validar préstamo
        SELECT COUNT(*)
        INTO v_existe
        FROM prestamo
        WHERE id_prestamo = p_id_prestamo;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20701,'El préstamo no existe.');
        END IF;

        SELECT saldo_prestamo, estado_prestamo
        INTO v_saldo_prestamo, v_estado
        FROM prestamo
        WHERE id_prestamo = p_id_prestamo;

        IF v_estado <> 'activo' THEN
            RAISE_APPLICATION_ERROR(-20702,'El préstamo no está activo.');
        END IF;

        IF p_monto_abono <= 0 THEN
            RAISE_APPLICATION_ERROR(-20703,'El monto del abono debe ser mayor a 0.');
        END IF;

        IF p_monto_abono > v_saldo_prestamo THEN
            RAISE_APPLICATION_ERROR(-20704,'El abono no puede ser mayor al saldo del préstamo.');
        END IF;

        -- Validar cuenta
        SELECT COUNT(*)
        INTO v_existe
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta
          AND estado_cuenta = 'activa';

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20705,'La cuenta no existe o no está activa.');
        END IF;

        SELECT saldo_cuenta
        INTO v_saldo_cuenta
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_saldo_cuenta < p_monto_abono THEN
            RAISE_APPLICATION_ERROR(-20706,'Saldo insuficiente en la cuenta.');
        END IF;

        -- Registrar transacción
        SELECT NVL(MAX(id_transaccion),0)+1
        INTO v_id_transaccion
        FROM transaccion;

        INSERT INTO transaccion (
            id_transaccion,
            id_cajero,
            id_tarjeta,
            id_cuenta_origen,
            id_cuenta_destino,
            fecha_transaccion,
            tipo_transaccion,
            monto_transaccion,
            estado_transaccion,
            descripcion_transaccion
        ) VALUES (
            v_id_transaccion,
            NULL,
            NULL,
            p_id_cuenta,
            NULL,
            SYSTIMESTAMP,
            'cuenta',
            p_monto_abono,
            'completada',
            'Abono extraordinario al préstamo ' || p_id_prestamo
        );

        o_id_transaccion := v_id_transaccion;

        -- Descontar saldo de la cuenta
        UPDATE cuenta
        SET saldo_cuenta = saldo_cuenta - p_monto_abono,
            fecha_ultima_transaccion_cuenta = SYSTIMESTAMP
        WHERE id_cuenta = p_id_cuenta;

        -- Insertar abono
        v_id_abono := function_generar_id_abono();

        INSERT INTO abono_extraordinario (
            id_abono,
            id_prestamo,
            id_transaccion,
            monto_abono,
            fecha_abono,
            tipo_abono
        ) VALUES (
            v_id_abono,
            p_id_prestamo,
            v_id_transaccion,
            p_monto_abono,
            SYSTIMESTAMP,
            p_tipo_abono
        );

        o_id_abono := v_id_abono;

        -- Recalcular saldo del préstamo
        pkgc_prestamos.procedure_actualizar_saldo(p_id_prestamo);

    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END procedure_registrar_abono;

    --------------------------------------------------------------------
    -- Listar abonos de un préstamo
    --------------------------------------------------------------------
    PROCEDURE procedure_listar_abonos(
        p_id_prestamo IN NUMBER,
        o_cursor      OUT SYS_REFCURSOR
    )
    IS
        v_existe NUMBER;
    BEGIN
        -- Validar que el préstamo existe
        SELECT COUNT(*)
        INTO v_existe
        FROM prestamo
        WHERE id_prestamo = p_id_prestamo;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20720,'El préstamo no existe.');
        END IF;

        -- Abrir el cursor con la consulta
        OPEN o_cursor FOR
            SELECT
                id_abono,
                id_transaccion,
                monto_abono,
                fecha_abono,
                tipo_abono
            FROM abono_extraordinario
            WHERE id_prestamo = p_id_prestamo
            ORDER BY fecha_abono DESC;
            
    EXCEPTION
        WHEN OTHERS THEN
            -- Cerrar el cursor si está abierto antes de relanzar el error
            IF o_cursor%ISOPEN THEN
                CLOSE o_cursor;
            END IF;
            RAISE;
    END procedure_listar_abonos;

END pkgc_abonos;


/
--------------------------------------------------------
--  DDL for Package Body PKGC_CAJEROS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKGC_CAJEROS" AS
    -- ========== CURSOR BÁSICO ==========
    CURSOR c_cajeros_activos IS
        SELECT id_cajero, id_sucursal, dinero_disponible_cajero, estado_cajero
        FROM cajero
        WHERE estado_cajero = 'activo'
        ORDER BY id_cajero;

    -------------------------------------------------------------------
    -- CREAR CAJERO
    -------------------------------------------------------------------
    PROCEDURE procedure_crear_cajero(
        p_id_sucursal   IN NUMBER,
        p_id_admin      IN NUMBER,
        p_dinero_inicial IN NUMBER,
        o_id_cajero     OUT NUMBER
    )
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;

        v_existe NUMBER;
        v_id NUMBER;
    BEGIN
        ----------------------------------------------------------------
        -- Validar sucursal
        ----------------------------------------------------------------
        SELECT COUNT(*)
        INTO v_existe
        FROM sucursal
        WHERE id_sucursal = p_id_sucursal;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-43001,'La sucursal no existe.');
        END IF;

        ----------------------------------------------------------------
        -- Validar admin
        ----------------------------------------------------------------
        SELECT COUNT(*)
        INTO v_existe
        FROM administrador
        WHERE id_administrador = p_id_admin;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-43002,'El administrador no existe.');
        END IF;

        ----------------------------------------------------------------
        -- Generar ID
        ----------------------------------------------------------------
        SELECT NVL(MAX(id_cajero),0)+1
        INTO v_id
        FROM cajero;

        INSERT INTO cajero (
            id_cajero,
            id_sucursal,
            id_administrador,
            dinero_disponible_cajero,
            estado_cajero,
            fecha_ultima_recarga_cajero
        ) VALUES (
            v_id,
            p_id_sucursal,
            p_id_admin,
            p_dinero_inicial,
            'activo',
            SYSTIMESTAMP
        );

        o_id_cajero := v_id;
        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END procedure_crear_cajero;

    -------------------------------------------------------------------
    -- CAMBIAR ESTADO DE CAJERO
    -------------------------------------------------------------------
    PROCEDURE procedure_cambiar_estado_cajero(
        p_id_cajero IN NUMBER,
        p_estado    IN VARCHAR2
    )
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;

        v_existe NUMBER;
    BEGIN
        IF LOWER(p_estado) NOT IN ('activo','inactivo') THEN
            RAISE_APPLICATION_ERROR(-43010,'Estado inválido.');
        END IF;

        SELECT COUNT(*)
        INTO v_existe
        FROM cajero
        WHERE id_cajero = p_id_cajero;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-43011,'El cajero no existe.');
        END IF;

        UPDATE cajero
        SET estado_cajero = LOWER(p_estado)
        WHERE id_cajero = p_id_cajero;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END procedure_cambiar_estado_cajero;

    -------------------------------------------------------------------
    -- RECARGAR CAJERO
    -------------------------------------------------------------------
    PROCEDURE procedure_recargar_cajero(
        p_id_cajero IN NUMBER,
        p_monto     IN NUMBER
    )
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;

        v_existe NUMBER;
    BEGIN
        IF p_monto <= 0 THEN
            RAISE_APPLICATION_ERROR(-43020,'El monto debe ser mayor a 0.');
        END IF;

        SELECT COUNT(*)
        INTO v_existe
        FROM cajero
        WHERE id_cajero = p_id_cajero;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-43021,'El cajero no existe.');
        END IF;

        UPDATE cajero
        SET dinero_disponible_cajero = dinero_disponible_cajero + p_monto,
            fecha_ultima_recarga_cajero = SYSTIMESTAMP
        WHERE id_cajero = p_id_cajero;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END procedure_recargar_cajero;

    -------------------------------------------------------------------
    -- DESCONTAR DINERO DEL CAJERO (RETIROS)
    -------------------------------------------------------------------
    PROCEDURE procedure_descontar_cajero(
        p_id_cajero IN NUMBER,
        p_monto     IN NUMBER
    )
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;

        v_dinero NUMBER;
        v_existe NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_existe
        FROM cajero
        WHERE id_cajero = p_id_cajero
          AND estado_cajero = 'activo';

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20007,'El cajero no existe o está inactivo.');
        END IF;

        SELECT dinero_disponible_cajero
        INTO v_dinero
        FROM cajero
        WHERE id_cajero = p_id_cajero;

        IF v_dinero < p_monto THEN
            RAISE_APPLICATION_ERROR(-2008,'El cajero no tiene suficiente efectivo.');
        END IF;

        UPDATE cajero
        SET dinero_disponible_cajero = dinero_disponible_cajero - p_monto
        WHERE id_cajero = p_id_cajero;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END procedure_descontar_cajero;

    -------------------------------------------------------------------
    -- LISTAR CAJEROS POR SUCURSAL
    -------------------------------------------------------------------
    PROCEDURE procedure_listar_cajeros(
        p_id_sucursal IN NUMBER,
        o_cursor      OUT SYS_REFCURSOR
    )
    IS
        v_existe NUMBER;
    BEGIN
        -- Validar que la sucursal existe
        SELECT COUNT(*)
        INTO v_existe
        FROM sucursal
        WHERE id_sucursal = p_id_sucursal;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-43040,'La sucursal no existe.');
        END IF;

        -- Abrir el cursor con la consulta
        OPEN o_cursor FOR
            SELECT 
                id_cajero,
                dinero_disponible_cajero,
                estado_cajero,
                fecha_ultima_recarga_cajero
            FROM cajero
            WHERE id_sucursal = p_id_sucursal
            ORDER BY id_cajero;
            
    EXCEPTION
        WHEN OTHERS THEN
            -- Cerrar el cursor si está abierto antes de relanzar el error
            IF o_cursor%ISOPEN THEN
                CLOSE o_cursor;
            END IF;
            RAISE;
    END procedure_listar_cajeros;

    -- ========== NUEVO PROCEDIMIENTO CON COLECCIONES ==========
    PROCEDURE procedure_obtener_cajeros_por_ids(
        p_ids IN t_lista_ids_cajero,
        p_resultado OUT t_lista_cajeros
    ) IS
        v_cajero t_info_cajero;
    BEGIN
        p_resultado := t_lista_cajeros();

        FOR i IN 1..p_ids.COUNT LOOP
            BEGIN
                SELECT id_cajero, id_sucursal, dinero_disponible_cajero, estado_cajero
                INTO v_cajero.id_cajero, v_cajero.id_sucursal,
                     v_cajero.dinero_disponible, v_cajero.estado
                FROM cajero
                WHERE id_cajero = p_ids(i);

                p_resultado.EXTEND;
                p_resultado(p_resultado.COUNT) := v_cajero;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END LOOP;
    END;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_cajeros_activos(
        o_resultado OUT t_lista_cajeros
    ) IS
        v_cajero t_info_cajero;
    BEGIN
        o_resultado := t_lista_cajeros();

        -- Usa el cursor básico declarado
        FOR reg IN c_cajeros_activos LOOP
            v_cajero.id_cajero := reg.id_cajero;
            v_cajero.id_sucursal := reg.id_sucursal;
            v_cajero.dinero_disponible := reg.dinero_disponible_cajero;
            v_cajero.estado := reg.estado_cajero;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_cajero;
        END LOOP;
    END procedure_listar_cajeros_activos;
END pkgc_cajeros;


/
--------------------------------------------------------
--  DDL for Package Body PKGC_CUOTAS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKGC_CUOTAS" AS

    FUNCTION function_generar_id_cuota RETURN NUMBER IS
        v_id NUMBER;
    BEGIN
        SELECT NVL(MAX(id_cuota),0) + 1
        INTO v_id
        FROM cuota;
        RETURN v_id;
    END function_generar_id_cuota;

    ----------------------------------------------------------------------
    -- Generar cuotas de un préstamo activo (CORREGIDO)
    ----------------------------------------------------------------------
    PROCEDURE procedure_generar_cuotas(
        p_id_prestamo IN NUMBER
    )
    IS
        v_estado      VARCHAR2(20);
        v_plazo       NUMBER;
        v_monto       NUMBER;
        v_valor_cuota NUMBER;
        v_fecha_ini   TIMESTAMP;
        v_i           NUMBER;
        v_id_cuota    NUMBER;
    BEGIN
        -- Traer datos del préstamo (si no existe → NO_DATA_FOUND)
        SELECT estado_prestamo,
               monto_prestamo,
               plazo_prestamo,
               fecha_inicio_prestamo
        INTO  v_estado,
              v_monto,
              v_plazo,
              v_fecha_ini
        FROM prestamo
        WHERE id_prestamo = p_id_prestamo;

        IF v_estado <> 'activo' THEN
            RAISE_APPLICATION_ERROR(-20602,'El préstamo debe estar activo para generar cuotas.');
        END IF;

        IF v_plazo <= 0 THEN
            RAISE_APPLICATION_ERROR(-20603,'El plazo del préstamo no es válido.');
        END IF;

        v_valor_cuota := ROUND(v_monto / v_plazo, 2);

        FOR v_i IN 1 .. v_plazo LOOP
            v_id_cuota := function_generar_id_cuota();

            INSERT INTO cuota (
                id_cuota,
                id_prestamo,
                numero_cuota,
                monto_de_cuota,
                capital_cuota,
                fecha_de_vencimiento_cuota,
                fecha_de_pago_cuota,
                estado_cuota
            ) VALUES (
                v_id_cuota,
                p_id_prestamo,
                v_i,
                v_valor_cuota,
                v_valor_cuota,  -- Por ahora capital = monto, pero puede cambiar si hay interés
                ADD_MONTHS(v_fecha_ini, v_i),  -- ✅ CORREGIDO: Suma MESES, no días
                NULL,
                'pendiente'
            );
        END LOOP;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Aviso: préstamo '||p_id_prestamo||' no existe al generar cuotas.');
        WHEN OTHERS THEN
            RAISE;
    END procedure_generar_cuotas;

    ----------------------------------------------------------------------
    -- Pagar cuota
    ----------------------------------------------------------------------
    PROCEDURE procedure_pagar_cuota(
        p_id_cuota        IN NUMBER,
        p_id_cuenta       IN NUMBER,
        o_id_transaccion  OUT NUMBER
    )
    IS
        v_monto    NUMBER;
        v_estado   VARCHAR2(10);
        v_prestamo NUMBER;
        v_saldo    NUMBER;
        v_existe   NUMBER;
        v_id_trx   NUMBER;
    BEGIN
        -- Validar cuota
        SELECT estado_cuota,
               monto_de_cuota,
               id_prestamo
        INTO  v_estado,
              v_monto,
              v_prestamo
        FROM cuota
        WHERE id_cuota = p_id_cuota;

        IF v_estado = 'pagada' THEN
            RAISE_APPLICATION_ERROR(-20612,'La cuota ya está pagada.');
        END IF;

        -- Validar cuenta
        SELECT COUNT(*)
        INTO v_existe
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta
          AND estado_cuenta = 'activa';

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20613,'La cuenta no existe o no está activa.');
        END IF;

        SELECT saldo_cuenta
        INTO v_saldo
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_saldo < v_monto THEN
            RAISE_APPLICATION_ERROR(-20614,'Saldo insuficiente para pagar la cuota.');
        END IF;

        -- Transacción
        SELECT NVL(MAX(id_transaccion),0)+1
        INTO v_id_trx
        FROM transaccion;

        INSERT INTO transaccion (
            id_transaccion,
            id_cajero,
            id_tarjeta,
            id_cuenta_origen,
            id_cuenta_destino,
            fecha_transaccion,
            tipo_transaccion,
            monto_transaccion,
            estado_transaccion,
            descripcion_transaccion
        ) VALUES (
            v_id_trx,
            NULL,
            NULL,
            p_id_cuenta,
            NULL,
            SYSTIMESTAMP,
            'cuenta',
            v_monto,
            'completada',
            'Pago cuota '||p_id_cuota||' del préstamo '||v_prestamo
        );

        o_id_transaccion := v_id_trx;

        -- Actualizar cuenta
        UPDATE cuenta
        SET saldo_cuenta = saldo_cuenta - v_monto,
            fecha_ultima_transaccion_cuenta = SYSTIMESTAMP
        WHERE id_cuenta = p_id_cuenta;

        -- Actualizar cuota
        UPDATE cuota
        SET estado_cuota = 'pagada',
            fecha_de_pago_cuota = SYSTIMESTAMP
        WHERE id_cuota = p_id_cuota;

        -- Recalcular saldo del préstamo
        pkgc_prestamos.procedure_actualizar_saldo(v_prestamo);

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20615,'La cuota no existe.');
        WHEN OTHERS THEN
            RAISE;
    END procedure_pagar_cuota;

    ----------------------------------------------------------------------
    -- Listar cuotas
    ----------------------------------------------------------------------
    PROCEDURE procedure_listar_cuotas(
        p_id_prestamo IN NUMBER,
        o_cursor      OUT SYS_REFCURSOR
    )
    IS
        v_existe NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_existe
        FROM prestamo
        WHERE id_prestamo = p_id_prestamo;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20620,'El préstamo no existe.');
        END IF;

        OPEN o_cursor FOR
            SELECT
                id_cuota,
                numero_cuota,
                monto_de_cuota,
                capital_cuota,
                fecha_de_vencimiento_cuota,
                fecha_de_pago_cuota,
                estado_cuota
            FROM cuota
            WHERE id_prestamo = p_id_prestamo
            ORDER BY numero_cuota;
    END procedure_listar_cuotas;

END pkgc_cuotas;


/
--------------------------------------------------------
--  DDL for Package Body PKG_CLIENTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKG_CLIENTES" AS
    -- Constantes
    c_estado_activo   CONSTANT VARCHAR2(10) := 'ACTIVO';
    c_estado_inactivo CONSTANT VARCHAR2(10) := 'INACTIVO';

    -- ========== CURSOR BÁSICO (no parametrizado) ==========
    CURSOR c_clientes_activos IS
        SELECT id_cliente, nombre_cliente, email_cliente, telefono_cliente
        FROM cliente
        WHERE estado_cliente = c_estado_activo
        ORDER BY nombre_cliente;

    -----------------------------------------------------------------
    -- SOLICITUDES: clientes que aún NO tienen cuenta
    -- EXPLAIN PLAN: Consulta principal para obtener solicitudes
    -----------------------------------------------------------------
    PROCEDURE procedure_obtener_solicitudes(
        result OUT SYS_REFCURSOR
    ) IS
    BEGIN
        -- ========== EXPLAIN PLAN PARA CONSULTA PRINCIPAL ==========
        -- Analizar plan de ejecución de la consulta de solicitudes
        EXECUTE IMMEDIATE 'EXPLAIN PLAN FOR
            SELECT 
                c.id_cliente,
                c.nombre_cliente,
                c.email_cliente,
                c.telefono_cliente,
                c.cedula_cliente,
                TO_CHAR(c.fecha_registro_cliente, ''YYYY-MM-DD HH24:MI'') AS fecha_registro
            FROM cliente c
            WHERE NOT EXISTS (
                SELECT 1 FROM cuenta cu
                WHERE cu.id_cliente = c.id_cliente
            )
            ORDER BY c.fecha_registro_cliente DESC';
        -- ============================================================

        OPEN result FOR
            SELECT 
                c.id_cliente,
                c.nombre_cliente,
                c.email_cliente,
                c.telefono_cliente,
                c.cedula_cliente,
                TO_CHAR(c.fecha_registro_cliente, 'YYYY-MM-DD HH24:MI') AS fecha_registro
            FROM cliente c
            WHERE NOT EXISTS (
                SELECT 1 FROM cuenta cu
                WHERE cu.id_cliente = c.id_cliente
            )
            ORDER BY c.fecha_registro_cliente DESC;
    END procedure_obtener_solicitudes;

    -----------------------------------------------------------------
    -- VALIDACIONES Y HELPERS
    -----------------------------------------------------------------
    PROCEDURE validar_estado(p_estado IN VARCHAR2) IS
    BEGIN
        IF p_estado NOT IN (c_estado_activo, c_estado_inactivo) THEN
            raise_application_error(-20001, 'Estado inválido.');
        END IF;
    END;

    PROCEDURE validar_email(p_email IN VARCHAR2) IS
    BEGIN
        IF p_email IS NULL OR
           NOT REGEXP_LIKE(p_email, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') THEN
            raise_application_error(-20002, 'Email con formato inválido.');
        END IF;
    END;

    PROCEDURE asegurar_cliente_existe(p_id_cliente IN VARCHAR2) IS
        v_dummy NUMBER;
    BEGIN
        SELECT 1 INTO v_dummy
        FROM cliente
        WHERE id_cliente = p_id_cliente;
    EXCEPTION WHEN NO_DATA_FOUND THEN
        raise_application_error(-20003, 'Cliente no existe: ' || p_id_cliente);
    END;

    -----------------------------------------------------------------
    -- FUNCTION function_generar_id_cliente
    -----------------------------------------------------------------
    FUNCTION function_generar_id_cliente RETURN VARCHAR2 IS
        v_max NUMBER;
    BEGIN
        SELECT NVL(MAX(TO_NUMBER(SUBSTR(id_cliente, 4))), 0)
        INTO v_max
        FROM cliente
        WHERE REGEXP_LIKE(id_cliente, '^CLI[0-9]{3}$');

        RETURN 'CLI' || LPAD(v_max + 1, 3, '0');
    END function_generar_id_cliente;

    -----------------------------------------------------------------
    FUNCTION function_existe_cliente(p_id_cliente IN VARCHAR2) RETURN BOOLEAN IS
        v_cnt NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_cnt
        FROM cliente
        WHERE id_cliente = p_id_cliente;
        RETURN v_cnt > 0;
    END function_existe_cliente;

    -----------------------------------------------------------------
    FUNCTION function_email_disponible(
        p_email      IN VARCHAR2,
        p_excluir_id IN VARCHAR2 DEFAULT NULL
    ) RETURN BOOLEAN IS
        v_cnt NUMBER;
    BEGIN
        IF p_excluir_id IS NULL THEN
            SELECT COUNT(*) INTO v_cnt
            FROM cliente
            WHERE UPPER(email_cliente) = UPPER(p_email);
        ELSE
            SELECT COUNT(*) INTO v_cnt
            FROM cliente
            WHERE UPPER(email_cliente) = UPPER(p_email)
              AND id_cliente <> p_excluir_id;
        END IF;

        RETURN v_cnt = 0;
    END function_email_disponible;

    -----------------------------------------------------------------
    -- PROCEDURE procedure_crear_cliente
    -----------------------------------------------------------------
    PROCEDURE procedure_crear_cliente(
        p_nombre_cliente        IN VARCHAR2,
        p_email_cliente         IN VARCHAR2,
        p_telefono_cliente      IN VARCHAR2,
        p_cedula_cliente        IN NUMBER,
        p_estado_cliente        IN VARCHAR2,
        o_id_cliente            OUT VARCHAR2
    ) IS
        v_id VARCHAR2(10);
        v_cnt NUMBER;
    BEGIN
        validar_estado(p_estado_cliente);
        validar_email(p_email_cliente);

        -- Email único
        IF NOT function_email_disponible(p_email_cliente) THEN
            raise_application_error(-20004, 'Email ya existe.');
        END IF;

        -- Cédula única
        SELECT COUNT(*) INTO v_cnt
        FROM cliente
        WHERE cedula_cliente = p_cedula_cliente;

        IF v_cnt > 0 THEN
            raise_application_error(-20005, 'Cédula ya existe.');
        END IF;

        v_id := function_generar_id_cliente;

        INSERT INTO cliente (
            id_cliente,
            nombre_cliente,
            email_cliente,
            telefono_cliente,
            estado_cliente,
            fecha_registro_cliente,
            cedula_cliente
        ) VALUES (
            v_id,
            p_nombre_cliente,
            p_email_cliente,
            p_telefono_cliente,
            p_estado_cliente,
            SYSTIMESTAMP,
            p_cedula_cliente
        );

        o_id_cliente := v_id;
    END procedure_crear_cliente;

    -----------------------------------------------------------------
    PROCEDURE procedure_actualizar_datos_cliente(
        p_id_cliente       IN VARCHAR2,
        p_nombre_cliente   IN VARCHAR2,
        p_email_cliente    IN VARCHAR2,
        p_telefono_cliente IN VARCHAR2,
        p_cedula_cliente   IN NUMBER
    ) IS
    BEGIN
        asegurar_cliente_existe(p_id_cliente);
        validar_email(p_email_cliente);

        -- Email único
        IF NOT function_email_disponible(p_email_cliente, p_id_cliente) THEN
            raise_application_error(-20006, 'Email ya está asignado.');
        END IF;

        UPDATE cliente
        SET nombre_cliente   = p_nombre_cliente,
            email_cliente    = p_email_cliente,
            telefono_cliente = p_telefono_cliente,
            cedula_cliente   = p_cedula_cliente
        WHERE id_cliente = p_id_cliente;
    END procedure_actualizar_datos_cliente;

    -----------------------------------------------------------------
    PROCEDURE procedure_actualizar_correo_cliente(
        p_id_cliente    IN VARCHAR2,
        p_email_cliente IN VARCHAR2
    ) IS
    BEGIN
        asegurar_cliente_existe(p_id_cliente);
        validar_email(p_email_cliente);

        IF NOT function_email_disponible(p_email_cliente, p_id_cliente) THEN
            raise_application_error(-20007, 'Email duplicado.');
        END IF;

        UPDATE cliente
        SET email_cliente = p_email_cliente
        WHERE id_cliente = p_id_cliente;
    END procedure_actualizar_correo_cliente;

    -----------------------------------------------------------------
    PROCEDURE procedure_actualizar_nombre_cliente(
        p_id_cliente       IN VARCHAR2,
        p_nombre_cliente   IN VARCHAR2
    ) IS
    BEGIN
        asegurar_cliente_existe(p_id_cliente);

        UPDATE cliente
        SET nombre_cliente = p_nombre_cliente
        WHERE id_cliente = p_id_cliente;
    END procedure_actualizar_nombre_cliente;

    -----------------------------------------------------------------
    PROCEDURE procedure_actualizar_telefono_cliente(
        p_id_cliente       IN VARCHAR2,
        p_telefono_cliente IN VARCHAR2
    ) IS
    BEGIN
        asegurar_cliente_existe(p_id_cliente);

        UPDATE cliente
        SET telefono_cliente = p_telefono_cliente
        WHERE id_cliente = p_id_cliente;
    END procedure_actualizar_telefono_cliente;

    -----------------------------------------------------------------
    PROCEDURE procedure_actualizar_cedula_cliente(
        p_id_cliente     IN VARCHAR2,
        p_cedula_cliente IN NUMBER
    ) IS
        v_cnt NUMBER;
    BEGIN
        asegurar_cliente_existe(p_id_cliente);

        SELECT COUNT(*) INTO v_cnt
        FROM cliente
        WHERE cedula_cliente = p_cedula_cliente
          AND id_cliente <> p_id_cliente;

        IF v_cnt > 0 THEN
            raise_application_error(-20008, 'Cédula duplicada.');
        END IF;

        UPDATE cliente
        SET cedula_cliente = p_cedula_cliente
        WHERE id_cliente = p_id_cliente;
    END procedure_actualizar_cedula_cliente;

    -----------------------------------------------------------------
    PROCEDURE procedure_eliminar_cliente(
        p_id_cliente IN VARCHAR2
    ) IS
        v_cnt NUMBER;
    BEGIN
        asegurar_cliente_existe(p_id_cliente);

        SELECT COUNT(*) INTO v_cnt
        FROM cuenta
        WHERE id_cliente = p_id_cliente;

        IF v_cnt > 0 THEN
            raise_application_error(-20009,'Cliente tiene cuentas.');
        END IF;

        UPDATE cliente
        SET estado_cliente = c_estado_inactivo
        WHERE id_cliente = p_id_cliente;
    END procedure_eliminar_cliente;

    -----------------------------------------------------------------
    -- CREAR CUENTA DESDE CLIENTES (para solicitudes)
    -----------------------------------------------------------------
    PROCEDURE procedure_crear_cuenta_cliente(
        p_id_cliente       IN VARCHAR2,
        p_id_administrador IN NUMBER,
        o_id_cuenta        OUT NUMBER
    ) IS
        v_exists NUMBER;
        v_cedula NUMBER;
    BEGIN
        asegurar_cliente_existe(p_id_cliente);

        SELECT COUNT(*) INTO v_exists
        FROM administrador
        WHERE id_administrador = p_id_administrador;

        IF v_exists = 0 THEN
            raise_application_error(-20010,'Administrador no existe.');
        END IF;

        SELECT cedula_cliente INTO v_cedula
        FROM cliente
        WHERE id_cliente = p_id_cliente;

        SELECT NVL(MAX(id_cuenta),0)+1
        INTO o_id_cuenta
        FROM cuenta;

        INSERT INTO cuenta (
            id_cuenta,
            id_cliente,
            id_administrador,
            saldo_cuenta,
            fecha_creacion_cuenta,
            estado_cuenta,
            contrasena_cuenta
        ) VALUES (
            o_id_cuenta,
            p_id_cliente,
            p_id_administrador,
            0,
            SYSTIMESTAMP,
            'activa',
            v_cedula
        );
    END procedure_crear_cuenta_cliente;

    -- ========== NUEVOS PROCEDIMIENTOS CON COLECCIONES ==========
    PROCEDURE procedure_obtener_clientes_por_ids(
        p_ids IN t_lista_ids_cliente,
        p_resultado OUT t_lista_clientes
    ) IS
        v_cliente t_info_cliente;
    BEGIN
        p_resultado := t_lista_clientes();

        FOR i IN 1..p_ids.COUNT LOOP
            SELECT id_cliente, nombre_cliente, email_cliente, telefono_cliente
            INTO v_cliente.id_cliente, v_cliente.nombre_cliente, 
                 v_cliente.email_cliente, v_cliente.telefono_cliente
            FROM cliente
            WHERE id_cliente = p_ids(i);

            p_resultado.EXTEND;
            p_resultado(p_resultado.COUNT) := v_cliente;
        END LOOP;
    END procedure_obtener_clientes_por_ids;

    PROCEDURE procedure_procesar_clientes_masivos(
        p_clientes IN t_lista_clientes,
        o_resultado OUT NUMBER
    ) IS
        v_exitosos NUMBER := 0;
    BEGIN
        -- ========== TRANSACCIÓN EXPLÍCITA ==========
        FOR i IN 1..p_clientes.COUNT LOOP
            BEGIN
                INSERT INTO cliente (
                    id_cliente, nombre_cliente, email_cliente, 
                    telefono_cliente, estado_cliente, fecha_registro_cliente
                ) VALUES (
                    p_clientes(i).id_cliente, p_clientes(i).nombre_cliente,
                    p_clientes(i).email_cliente, p_clientes(i).telefono_cliente,
                    c_estado_activo, SYSTIMESTAMP
                );
                v_exitosos := v_exitosos + 1;
            EXCEPTION
                WHEN OTHERS THEN
                    ROLLBACK;
                    RAISE;
            END;
        END LOOP;

        COMMIT;
        o_resultado := v_exitosos;
    END procedure_procesar_clientes_masivos;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_clientes_activos(
        o_resultado OUT t_lista_clientes
    ) IS
        v_cliente t_info_cliente;
    BEGIN
        o_resultado := t_lista_clientes();

        -- Usa el cursor básico declarado
        FOR reg IN c_clientes_activos LOOP
            v_cliente.id_cliente := reg.id_cliente;
            v_cliente.nombre_cliente := reg.nombre_cliente;
            v_cliente.email_cliente := reg.email_cliente;
            v_cliente.telefono_cliente := reg.telefono_cliente;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_cliente;
        END LOOP;
    END procedure_listar_clientes_activos;
END pkg_clientes;


/
--------------------------------------------------------
--  DDL for Package Body PKGC_PRESTAMOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKGC_PRESTAMOS" AS
    -- ========== CURSOR BÁSICO ==========
    CURSOR c_prestamos_activos IS
        SELECT id_prestamo, id_cuenta, monto_prestamo, saldo_prestamo, estado_prestamo
        FROM prestamo
        WHERE estado_prestamo = 'activo'
        ORDER BY id_prestamo;

    FUNCTION function_generar_id_prestamo RETURN NUMBER IS
        v_id NUMBER;
    BEGIN
        SELECT NVL(MAX(id_prestamo),0) + 1 INTO v_id FROM prestamo;
        RETURN v_id;
    END;

    --------------------------------------------------------------------
    -- Solicitar préstamo (MODIFICADO: ahora usa ID_CUENTA)
    --------------------------------------------------------------------
    PROCEDURE procedure_solicitar_prestamo(
        p_id_cuenta IN NUMBER, p_id_sucursal IN NUMBER,
        p_monto IN NUMBER, p_fecha_inicio IN DATE, p_fecha_fin IN DATE,
        o_id_prestamo OUT NUMBER
    ) IS
        v_existe NUMBER;
        v_id_prestamo NUMBER;
    BEGIN
        IF p_monto <= 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El monto solicitado debe ser mayor que 0.');
        END IF;

        IF p_fecha_fin <= p_fecha_inicio THEN
            RAISE_APPLICATION_ERROR(-20002, 'La fecha fin debe ser mayor que la fecha inicio.');
        END IF;

        -- Cuenta existe y está activa
        SELECT COUNT(*) INTO v_existe 
        FROM cuenta 
        WHERE id_cuenta = p_id_cuenta 
          AND estado_cuenta = 'activa';
        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20003, 'La cuenta no existe o no está activa.');
        END IF;

        -- Sucursal existe
        SELECT COUNT(*) INTO v_existe FROM sucursal WHERE id_sucursal = p_id_sucursal;
        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20004, 'La sucursal no existe.');
        END IF;

        -- Generar ID
        v_id_prestamo := function_generar_id_prestamo();

        -- Insertar el préstamo como "solicitado"
        INSERT INTO prestamo (
            id_prestamo, id_sucursal, monto_prestamo, tasa_de_interes_prestamo,
            plazo_prestamo, fecha_inicio_prestamo, fecha_vencimiento_prestamo,
            estado_prestamo, fecha_ultimo_pago_prestamo, saldo_prestamo, id_cuenta
        ) VALUES (
            v_id_prestamo, p_id_sucursal, p_monto, 0,
            0, p_fecha_inicio, p_fecha_fin,
            'solicitado', NULL, p_monto, p_id_cuenta
        );

        o_id_prestamo := v_id_prestamo;
    END procedure_solicitar_prestamo;

    --------------------------------------------------------------------
    -- Listar solicitudes de préstamo por sucursal
    -- EXPLAIN PLAN: Consulta principal para listar solicitudes
    --------------------------------------------------------------------
    PROCEDURE procedure_listar_solicitudes(p_id_sucursal IN NUMBER, o_cursor OUT SYS_REFCURSOR) IS
        v_existe NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_existe FROM sucursal WHERE id_sucursal = p_id_sucursal;
        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20010, 'La sucursal no existe.');
        END IF;

        -- ========== EXPLAIN PLAN PARA CONSULTA PRINCIPAL ==========
        -- Analizar plan de ejecución de la consulta de solicitudes
        EXECUTE IMMEDIATE 'EXPLAIN PLAN FOR
            SELECT id_prestamo, id_cuenta, monto_prestamo, fecha_inicio_prestamo,
                   fecha_vencimiento_prestamo, estado_prestamo
            FROM prestamo
            WHERE id_sucursal = :1 AND estado_prestamo = ''solicitado''
            ORDER BY fecha_inicio_prestamo DESC' USING p_id_sucursal;
        -- ============================================================

        OPEN o_cursor FOR
            SELECT id_prestamo, id_cuenta, monto_prestamo, fecha_inicio_prestamo,
                   fecha_vencimiento_prestamo, estado_prestamo
            FROM prestamo
            WHERE id_sucursal = p_id_sucursal AND estado_prestamo = 'solicitado'
            ORDER BY fecha_inicio_prestamo DESC;
    END;

    PROCEDURE procedure_aceptar(p_id_prestamo IN NUMBER) IS
        v_existe NUMBER;
        v_monto NUMBER;
        v_dias NUMBER;
    BEGIN
        -- Validar préstamo existe
        SELECT COUNT(*) INTO v_existe FROM prestamo WHERE id_prestamo = p_id_prestamo;
        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20020, 'El préstamo no existe.');
        END IF;

        -- Validar estado solicitado
        SELECT COUNT(*) INTO v_existe
        FROM prestamo
        WHERE id_prestamo = p_id_prestamo AND estado_prestamo = 'solicitado';
        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20021, 'El préstamo no está en estado solicitado.');
        END IF;

        -- Calcular plazo en días
        SELECT 
               EXTRACT(DAY FROM (fecha_vencimiento_prestamo - fecha_inicio_prestamo))
             + EXTRACT(HOUR   FROM (fecha_vencimiento_prestamo - fecha_inicio_prestamo)) / 24
             + EXTRACT(MINUTE FROM (fecha_vencimiento_prestamo - fecha_inicio_prestamo)) / 1440
             + EXTRACT(SECOND FROM (fecha_vencimiento_prestamo - fecha_inicio_prestamo)) / 86400
        INTO v_dias
        FROM prestamo WHERE id_prestamo = p_id_prestamo;

        IF v_dias <= 0 THEN
            RAISE_APPLICATION_ERROR(-20022, 'El plazo calculado del préstamo no es válido.');
        END IF;

        -- Activar préstamo
        UPDATE prestamo
        SET tasa_de_interes_prestamo = 10,
            plazo_prestamo = v_dias,
            estado_prestamo = 'activo',
            saldo_prestamo = monto_prestamo
        WHERE id_prestamo = p_id_prestamo;
    END;

    PROCEDURE procedure_rechazar(p_id_prestamo IN NUMBER) IS
        v_existe NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_existe FROM prestamo WHERE id_prestamo = p_id_prestamo;
        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20030, 'El préstamo no existe.');
        END IF;

        UPDATE prestamo SET estado_prestamo = 'rechazado' WHERE id_prestamo = p_id_prestamo;
    END;

    PROCEDURE procedure_actualizar_saldo(p_id_prestamo IN NUMBER) IS
        v_monto_ini NUMBER;
        v_abonos NUMBER;
        v_cuotas NUMBER;
        v_nuevo NUMBER;
    BEGIN
        -- Saldo inicial (monto del préstamo)
        SELECT monto_prestamo INTO v_monto_ini
        FROM prestamo WHERE id_prestamo = p_id_prestamo;

        -- Total abonos extraordinarios
        SELECT NVL(SUM(monto_abono), 0) INTO v_abonos
        FROM abono_extraordinario WHERE id_prestamo = p_id_prestamo;

        -- Total pagado en cuotas
        SELECT NVL(SUM(capital_cuota), 0) INTO v_cuotas
        FROM cuota WHERE id_prestamo = p_id_prestamo AND estado_cuota = 'pagada';

        v_nuevo := v_monto_ini - (v_abonos + v_cuotas);
        IF v_nuevo < 0 THEN v_nuevo := 0; END IF;

        UPDATE prestamo
        SET saldo_prestamo = v_nuevo,
            fecha_ultimo_pago_prestamo = SYSTIMESTAMP
        WHERE id_prestamo = p_id_prestamo;
    END;

    -- ========== NUEVO PROCEDIMIENTO CON COLECCIONES ==========
    PROCEDURE procedure_obtener_prestamos_por_ids(
        p_ids IN t_lista_ids_prestamo,
        p_resultado OUT t_lista_prestamos
    ) IS
        v_prestamo t_info_prestamo;
    BEGIN
        p_resultado := t_lista_prestamos();

        FOR i IN 1..p_ids.COUNT LOOP
            BEGIN
                SELECT id_prestamo, id_cuenta, monto_prestamo, saldo_prestamo, estado_prestamo
                INTO v_prestamo.id_prestamo, v_prestamo.id_cuenta,
                     v_prestamo.monto_prestamo, v_prestamo.saldo_prestamo, v_prestamo.estado_prestamo
                FROM prestamo
                WHERE id_prestamo = p_ids(i);

                p_resultado.EXTEND;
                p_resultado(p_resultado.COUNT) := v_prestamo;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END LOOP;
    END;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_prestamos_activos(
        o_resultado OUT t_lista_prestamos
    ) IS
        v_prestamo t_info_prestamo;
    BEGIN
        o_resultado := t_lista_prestamos();

        -- Usa el cursor básico declarado
        FOR reg IN c_prestamos_activos LOOP
            v_prestamo.id_prestamo := reg.id_prestamo;
            v_prestamo.id_cuenta := reg.id_cuenta;
            v_prestamo.monto_prestamo := reg.monto_prestamo;
            v_prestamo.saldo_prestamo := reg.saldo_prestamo;
            v_prestamo.estado_prestamo := reg.estado_prestamo;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_prestamo;
        END LOOP;
    END procedure_listar_prestamos_activos;
END pkgc_prestamos;


/
--------------------------------------------------------
--  DDL for Package Body PKGC_TARJETAS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKGC_TARJETAS" AS
    -- ========== CURSOR BÁSICO ==========
    CURSOR c_tarjetas_activas IS
        SELECT t.id_tarjeta, t.id_cuenta, t.numero_tarjeta, t.estado_tarjeta,
               CASE WHEN tc.id_tarjeta IS NOT NULL THEN 'CREDITO'
                    WHEN td.id_tarjeta IS NOT NULL THEN 'DEBITO'
                    ELSE 'DESCONOCIDO' END AS tipo_tarjeta
        FROM tarjeta t
        LEFT JOIN tarjeta_credito tc ON t.id_tarjeta = tc.id_tarjeta
        LEFT JOIN tarjeta_debito td ON t.id_tarjeta = td.id_tarjeta
        WHERE t.estado_tarjeta = 'activa'
        ORDER BY t.id_tarjeta;

    FUNCTION function_generar_id_tarjeta RETURN NUMBER IS
        v_id NUMBER;
    BEGIN
        SELECT NVL(MAX(id_tarjeta), 0) + 1 INTO v_id FROM tarjeta;
        RETURN v_id;
    END;

    -------------------------------------------------------------------
    -- Crear TARJETA DE DÉBITO
    -------------------------------------------------------------------
    PROCEDURE procedure_crear_tarjeta_debito(
        p_id_cuenta           IN NUMBER,
        p_limite_retiro       IN NUMBER,
        o_id_tarjeta          OUT NUMBER
    )
    IS
        v_existe NUMBER;
        v_id_tarjeta NUMBER;
        v_numero VARCHAR2(25);
        v_cvv     VARCHAR2(3);
    BEGIN
        ----------------------------------------------------------------
        -- Validar cuenta
        ----------------------------------------------------------------
        SELECT COUNT(*)
        INTO v_existe
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta
          AND LOWER(estado_cuenta) = 'activa';

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20101, 'La cuenta no existe o no está activa.');
        END IF;

        ----------------------------------------------------------------
        -- Generar tarjeta
        ----------------------------------------------------------------
        v_id_tarjeta := function_generar_id_tarjeta();
        v_numero := TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1000000000000000, 9999999999999999)));
        v_cvv    := LPAD(TRUNC(DBMS_RANDOM.VALUE(1,999)), 3, '0');

        INSERT INTO tarjeta (
            id_tarjeta,
            id_cuenta,
            numero_tarjeta,
            cvv_tarjeta,
            fecha_emision_tarjeta,
            fecha_vencimiento_tarjeta,
            estado_tarjeta
        ) VALUES (
            v_id_tarjeta,
            p_id_cuenta,
            v_numero,
            v_cvv,
            SYSTIMESTAMP,
            ADD_MONTHS(SYSTIMESTAMP, 48),
            'activa'
        );

        INSERT INTO tarjeta_debito (
            id_tarjeta,
            limite_retiro_debito,
            saldo_actual_debito
        ) VALUES (
            v_id_tarjeta,
            p_limite_retiro,
            0
        );

        o_id_tarjeta := v_id_tarjeta;
    END procedure_crear_tarjeta_debito;

    -------------------------------------------------------------------
    -- Crear TARJETA DE CRÉDITO
    -------------------------------------------------------------------
    PROCEDURE procedure_crear_tarjeta_credito(
        p_id_cuenta           IN NUMBER,
        p_limite_credito      IN NUMBER,
        p_tasa_interes        IN NUMBER,
        p_cuota_manejo        IN NUMBER,
        p_fecha_corte         IN NUMBER,
        o_id_tarjeta          OUT NUMBER
    )
    IS
        v_existe NUMBER;
        v_id_tarjeta NUMBER;
        v_numero VARCHAR2(25);
        v_cvv     VARCHAR2(3);
    BEGIN

        SELECT COUNT(*)
        INTO v_existe
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta
          AND LOWER(estado_cuenta) = 'activa';

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20111, 'La cuenta no existe o no está activa.');
        END IF;

        v_id_tarjeta := function_generar_id_tarjeta();
        v_numero := TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1000000000000000, 9999999999999999)));
        v_cvv    := LPAD(TRUNC(DBMS_RANDOM.VALUE(1,999)), 3, '0');

        INSERT INTO tarjeta (
            id_tarjeta,
            id_cuenta,
            numero_tarjeta,
            cvv_tarjeta,
            fecha_emision_tarjeta,
            fecha_vencimiento_tarjeta,
            estado_tarjeta
        ) VALUES (
            v_id_tarjeta,
            p_id_cuenta,
            v_numero,
            v_cvv,
            SYSTIMESTAMP,
            ADD_MONTHS(SYSTIMESTAMP, 48),
            'activa'
        );

        INSERT INTO tarjeta_credito (
            id_tarjeta,
            tasa_interes_credito,
            limite_credito,
            cuota_manejo_credito,
            fecha_pago_credito,
            fecha_corte_credito
        ) VALUES (
            v_id_tarjeta,
            p_tasa_interes,
            p_limite_credito,
            p_cuota_manejo,
            SYSTIMESTAMP,
            p_fecha_corte
        );

        o_id_tarjeta := v_id_tarjeta;
    END procedure_crear_tarjeta_credito;

    -------------------------------------------------------------------
    -- Cambiar estado de tarjeta
    -------------------------------------------------------------------
    PROCEDURE procedure_cambiar_estado_tarjeta(
        p_id_tarjeta IN NUMBER,
        p_estado     IN VARCHAR2
    )
    IS
        v_existe NUMBER;
    BEGIN
        IF LOWER(p_estado) NOT IN ('activa','inactiva','suspendida','bloqueada') THEN
            RAISE_APPLICATION_ERROR(-20121,'Estado inválido.');
        END IF;

        SELECT COUNT(*)
        INTO v_existe
        FROM tarjeta
        WHERE id_tarjeta = p_id_tarjeta;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20122,'La tarjeta no existe.');
        END IF;

        UPDATE tarjeta
        SET estado_tarjeta = LOWER(p_estado)
        WHERE id_tarjeta = p_id_tarjeta;
    END procedure_cambiar_estado_tarjeta;

    -------------------------------------------------------------------
    -- Listar tarjetas asociadas a una cuenta
    -------------------------------------------------------------------
    PROCEDURE procedure_listar_tarjetas(
        p_id_cuenta IN NUMBER,
        o_cursor    OUT SYS_REFCURSOR
    )
    IS
        v_existe NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO v_existe
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_existe = 0 THEN
            RAISE_APPLICATION_ERROR(-20130,'La cuenta no existe.');
        END IF;

        OPEN o_cursor FOR
            SELECT
                t.id_tarjeta,
                t.numero_tarjeta,
                t.cvv_tarjeta,
                t.estado_tarjeta,
                t.fecha_emision_tarjeta,
                t.fecha_vencimiento_tarjeta,
                CASE
                    WHEN tc.id_tarjeta IS NOT NULL THEN 'credito'
                    WHEN td.id_tarjeta IS NOT NULL THEN 'debito'
                END AS tipo_tarjeta
            FROM tarjeta t
            LEFT JOIN tarjeta_credito tc ON t.id_tarjeta = tc.id_tarjeta
            LEFT JOIN tarjeta_debito td  ON t.id_tarjeta = td.id_tarjeta
            WHERE t.id_cuenta = p_id_cuenta
            ORDER BY t.id_tarjeta;
    END procedure_listar_tarjetas;

    -- ========== NUEVO PROCEDIMIENTO CON COLECCIONES ==========
    PROCEDURE procedure_obtener_tarjetas_por_ids(
        p_ids IN t_lista_ids_tarjeta,
        p_resultado OUT t_lista_tarjetas
    ) IS
        v_tarjeta t_info_tarjeta;
    BEGIN
        p_resultado := t_lista_tarjetas();

        FOR i IN 1..p_ids.COUNT LOOP
            BEGIN
                SELECT t.id_tarjeta, t.id_cuenta, t.numero_tarjeta, t.estado_tarjeta,
                       CASE WHEN tc.id_tarjeta IS NOT NULL THEN 'CREDITO'
                            WHEN td.id_tarjeta IS NOT NULL THEN 'DEBITO'
                            ELSE 'DESCONOCIDO' END
                INTO v_tarjeta.id_tarjeta, v_tarjeta.id_cuenta, v_tarjeta.numero_tarjeta,
                     v_tarjeta.estado_tarjeta, v_tarjeta.tipo_tarjeta
                FROM tarjeta t
                LEFT JOIN tarjeta_credito tc ON t.id_tarjeta = tc.id_tarjeta
                LEFT JOIN tarjeta_debito td ON t.id_tarjeta = td.id_tarjeta
                WHERE t.id_tarjeta = p_ids(i);

                p_resultado.EXTEND;
                p_resultado(p_resultado.COUNT) := v_tarjeta;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END LOOP;
    END;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_tarjetas_activas(
        o_resultado OUT t_lista_tarjetas
    ) IS
        v_tarjeta t_info_tarjeta;
    BEGIN
        o_resultado := t_lista_tarjetas();

        -- Usa el cursor básico declarado
        FOR reg IN c_tarjetas_activas LOOP
            v_tarjeta.id_tarjeta := reg.id_tarjeta;
            v_tarjeta.id_cuenta := reg.id_cuenta;
            v_tarjeta.numero_tarjeta := reg.numero_tarjeta;
            v_tarjeta.estado_tarjeta := reg.estado_tarjeta;
            v_tarjeta.tipo_tarjeta := reg.tipo_tarjeta;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_tarjeta;
        END LOOP;
    END procedure_listar_tarjetas_activas;
END pkgc_tarjetas;


/
--------------------------------------------------------
--  DDL for Package Body PKGC_TRANSACCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKGC_TRANSACCIONES" AS
    -- ========== CURSOR BÁSICO ==========
    CURSOR c_transacciones_hoy IS
        SELECT id_transaccion, monto_transaccion, fecha_transaccion,
               estado_transaccion, tipo_transaccion
        FROM transaccion
        WHERE TRUNC(fecha_transaccion) = TRUNC(SYSDATE)
          AND estado_transaccion = 'completada'
        ORDER BY fecha_transaccion DESC;

    FUNCTION function_generar_id_transaccion RETURN NUMBER IS
        v_id NUMBER;
    BEGIN
        SELECT NVL(MAX(id_transaccion), 0) + 1 INTO v_id FROM transaccion;
        RETURN v_id;
    END;

    ------------------------------------------------------------------
    -- TRANSFERENCIA ENTRE CUENTAS (SIN DEADLOCK)
    ------------------------------------------------------------------
    PROCEDURE procedure_transferencia(
        p_cuenta_origen  IN NUMBER,
        p_cuenta_destino IN NUMBER,
        p_monto          IN NUMBER,
        o_id_transaccion OUT NUMBER
    )
    IS
        v_saldo_origen NUMBER;
        v_estado_origen VARCHAR2(10);
        v_estado_destino VARCHAR2(10);
        v_id_trx NUMBER;
    BEGIN
        IF p_monto <= 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El monto debe ser mayor que cero.');
        END IF;

        IF p_cuenta_origen = p_cuenta_destino THEN
            RAISE_APPLICATION_ERROR(-20002, 'La cuenta origen y destino no pueden ser la misma.');
        END IF;

        ------------------------------------------------------------------
        -- BLOQUEO SIEMPRE EN EL MISMO ORDEN → ORIGEN → DESTINO
        ------------------------------------------------------------------
        SELECT estado_cuenta, saldo_cuenta 
        INTO v_estado_origen, v_saldo_origen
        FROM cuenta
        WHERE id_cuenta = p_cuenta_origen
        FOR UPDATE;

        IF v_estado_origen <> 'activa' THEN
            RAISE_APPLICATION_ERROR(-20005, 'La cuenta origen no está activa.');
        END IF;

        SELECT estado_cuenta
        INTO v_estado_destino
        FROM cuenta
        WHERE id_cuenta = p_cuenta_destino
        FOR UPDATE;

        IF v_estado_destino <> 'activa' THEN
            RAISE_APPLICATION_ERROR(-20006, 'La cuenta destino no está activa.');
        END IF;

        IF v_saldo_origen < p_monto THEN
            RAISE_APPLICATION_ERROR(-20007, 'Saldo insuficiente.');
        END IF;

        UPDATE cuenta
        SET saldo_cuenta = saldo_cuenta - p_monto,
            fecha_ultima_transaccion_cuenta = SYSTIMESTAMP
        WHERE id_cuenta = p_cuenta_origen;

        UPDATE cuenta
        SET saldo_cuenta = saldo_cuenta + p_monto,
            fecha_ultima_transaccion_cuenta = SYSTIMESTAMP
        WHERE id_cuenta = p_cuenta_destino;

        v_id_trx := function_generar_id_transaccion;

        INSERT INTO transaccion (
            id_transaccion, id_cajero, id_tarjeta,
            id_cuenta_origen, id_cuenta_destino,
            fecha_transaccion, tipo_transaccion,
            monto_transaccion, estado_transaccion,
            descripcion_transaccion
        ) VALUES (
            v_id_trx,
            NULL, NULL,
            p_cuenta_origen, p_cuenta_destino,
            SYSTIMESTAMP, 'cuenta',
            p_monto, 'completada',
            'Transferencia entre cuentas'
        );

        o_id_transaccion := v_id_trx;
    END procedure_transferencia;

    ------------------------------------------------------------------
    -- RETIRO CON TARJETA DE DÉBITO (SIN DEADLOCK)
    ------------------------------------------------------------------
    PROCEDURE procedure_retiro_debito(
        p_id_tarjeta     IN NUMBER,
        p_id_cajero      IN NUMBER,
        p_monto          IN NUMBER,
        o_id_transaccion OUT NUMBER
    )
    IS
        v_id_cuenta NUMBER;
        v_saldo NUMBER;
        v_limite NUMBER;
        v_dinero_cajero NUMBER;
        v_estado_tar varchar2(10);
        v_estado_caj varchar2(10);
        v_trx NUMBER;
    BEGIN
        IF p_monto <= 0 THEN
            RAISE_APPLICATION_ERROR(-20101, 'El monto debe ser mayor que cero.');
        END IF;

        SELECT id_cuenta, estado_tarjeta
        INTO v_id_cuenta, v_estado_tar
        FROM tarjeta
        WHERE id_tarjeta = p_id_tarjeta
        FOR UPDATE;

        IF v_estado_tar <> 'activa' THEN
            RAISE_APPLICATION_ERROR(-20103, 'La tarjeta no está activa.');
        END IF;

        SELECT limite_retiro_debito
        INTO v_limite
        FROM tarjeta_debito
        WHERE id_tarjeta = p_id_tarjeta;

        IF p_monto > v_limite THEN
            RAISE_APPLICATION_ERROR(-20104, 'Excede el límite de retiro.');
        END IF;

        ------------------------------------------------------------------
        -- BLOQUEO DE CUENTA → LUEGO CAJERO (orden consistente)
        ------------------------------------------------------------------
        SELECT saldo_cuenta
        INTO v_saldo
        FROM cuenta
        WHERE id_cuenta = v_id_cuenta
        FOR UPDATE;

        IF v_saldo < p_monto THEN
            RAISE_APPLICATION_ERROR(-20105, 'Saldo insuficiente.');
        END IF;

        SELECT dinero_disponible_cajero, estado_cajero
        INTO v_dinero_cajero, v_estado_caj
        FROM cajero
        WHERE id_cajero = p_id_cajero
        FOR UPDATE;

        IF v_estado_caj <> 'activo' THEN
            RAISE_APPLICATION_ERROR(-20106, 'Cajero fuera de servicio.');
        END IF;

        IF v_dinero_cajero < p_monto THEN
            RAISE_APPLICATION_ERROR(-20107, 'Cajero sin suficiente dinero.');
        END IF;

        UPDATE cuenta
        SET saldo_cuenta = saldo_cuenta - p_monto
        WHERE id_cuenta = v_id_cuenta;

        UPDATE cajero
        SET dinero_disponible_cajero = dinero_disponible_cajero - p_monto
        WHERE id_cajero = p_id_cajero;

        v_trx := function_generar_id_transaccion;

        INSERT INTO transaccion (
            id_transaccion, id_cajero, id_tarjeta,
            id_cuenta_origen, id_cuenta_destino,
            fecha_transaccion, tipo_transaccion,
            monto_transaccion, estado_transaccion,
            descripcion_transaccion
        ) VALUES (
            v_trx, p_id_cajero, p_id_tarjeta,
            v_id_cuenta, NULL,
            SYSTIMESTAMP, 'cajero',
            p_monto, 'completada',
            'Retiro débito'
        );

        o_id_transaccion := v_trx;
    END procedure_retiro_debito;

    ------------------------------------------------------------------
    -- RETIRO CON TARJETA DE CRÉDITO (SIN DEADLOCK)
    ------------------------------------------------------------------
    PROCEDURE procedure_retiro_credito(
        p_id_tarjeta     IN NUMBER,
        p_id_cajero      IN NUMBER,
        p_monto          IN NUMBER,
        o_id_transaccion OUT NUMBER
    )
    IS
        v_estado_tar VARCHAR2(10);
        v_limite NUMBER;
        v_dinero_cajero NUMBER;
        v_estado_caj VARCHAR2(10);
        v_trx NUMBER;
    BEGIN
        IF p_monto <= 0 THEN
            RAISE_APPLICATION_ERROR(-20201, 'El monto debe ser mayor que cero.');
        END IF;

        SELECT estado_tarjeta
        INTO v_estado_tar
        FROM tarjeta
        WHERE id_tarjeta = p_id_tarjeta
        FOR UPDATE;

        IF v_estado_tar <> 'activa' THEN
            RAISE_APPLICATION_ERROR(-20203, 'La tarjeta no está activa.');
        END IF;

        SELECT limite_credito
        INTO v_limite
        FROM tarjeta_credito
        WHERE id_tarjeta = p_id_tarjeta;

        IF p_monto > v_limite THEN
            RAISE_APPLICATION_ERROR(-20204, 'Excede el límite de crédito.');
        END IF;

        SELECT dinero_disponible_cajero, estado_cajero
        INTO v_dinero_cajero, v_estado_caj
        FROM cajero
        WHERE id_cajero = p_id_cajero
        FOR UPDATE;

        IF v_estado_caj <> 'activo' THEN
            RAISE_APPLICATION_ERROR(-20206, 'Cajero fuera de servicio.');
        END IF;

        IF v_dinero_cajero < p_monto THEN
            RAISE_APPLICATION_ERROR(-20207, 'Cajero sin suficiente dinero.');
        END IF;

        UPDATE cajero
        SET dinero_disponible_cajero = dinero_disponible_cajero - p_monto
        WHERE id_cajero = p_id_cajero;

        v_trx := function_generar_id_transaccion;

        INSERT INTO transaccion (
            id_transaccion, id_cajero, id_tarjeta,
            id_cuenta_origen, id_cuenta_destino,
            fecha_transaccion, tipo_transaccion,
            monto_transaccion, estado_transaccion,
            descripcion_transaccion
        ) VALUES (
            v_trx, p_id_cajero, p_id_tarjeta,
            NULL, NULL,
            SYSTIMESTAMP, 'cajero',
            p_monto, 'completada',
            'Retiro crédito'
        );

        o_id_transaccion := v_trx;
    END procedure_retiro_credito;

    ------------------------------------------------------------------
    -- HISTORIAL DE CUENTA
    -- EXPLAIN PLAN: Consulta principal para historial de transacciones
    ------------------------------------------------------------------
    PROCEDURE procedure_historial_cuenta(
        p_id_cuenta IN NUMBER,
        o_cursor OUT SYS_REFCURSOR
    )
    IS
    BEGIN
        -- ========== EXPLAIN PLAN PARA CONSULTA PRINCIPAL ==========
        -- Analizar plan de ejecución de la consulta de historial
        EXECUTE IMMEDIATE 'EXPLAIN PLAN FOR
            SELECT * FROM transaccion
            WHERE tipo_transaccion=''cuenta''
            AND (id_cuenta_origen=:1
                OR id_cuenta_destino=:1)
            ORDER BY fecha_transaccion DESC' USING p_id_cuenta;
        -- ============================================================

        OPEN o_cursor FOR
            SELECT * FROM transaccion
            WHERE tipo_transaccion='cuenta'
            AND (id_cuenta_origen=p_id_cuenta
                OR id_cuenta_destino=p_id_cuenta)
            ORDER BY fecha_transaccion DESC;
    END procedure_historial_cuenta;

    ------------------------------------------------------------------
    -- HISTORIAL DE CAJERO POR CUENTA
    ------------------------------------------------------------------
    PROCEDURE procedure_historial_cajero(
        p_id_cuenta IN NUMBER,
        o_cursor OUT SYS_REFCURSOR
    )
    IS
    BEGIN
        OPEN o_cursor FOR
            SELECT t.* 
            FROM transaccion t
            JOIN tarjeta tar ON tar.id_tarjeta = t.id_tarjeta
            WHERE tipo_transaccion='cajero'
              AND tar.id_cuenta = p_id_cuenta
            ORDER BY fecha_transaccion DESC;
    END procedure_historial_cajero;

    -- ========== NUEVO PROCEDIMIENTO CON COLECCIONES ==========
    PROCEDURE procedure_obtener_transacciones_por_ids(
        p_ids IN t_lista_ids_transaccion,
        p_resultado OUT t_lista_transacciones
    ) IS
        v_transaccion t_info_transaccion;
    BEGIN
        p_resultado := t_lista_transacciones();

        FOR i IN 1..p_ids.COUNT LOOP
            BEGIN
                SELECT id_transaccion, monto_transaccion, fecha_transaccion,
                       estado_transaccion, tipo_transaccion
                INTO v_transaccion.id_transaccion, v_transaccion.monto_transaccion,
                     v_transaccion.fecha_transaccion, v_transaccion.estado_transaccion,
                     v_transaccion.tipo_transaccion
                FROM transaccion
                WHERE id_transaccion = p_ids(i);

                p_resultado.EXTEND;
                p_resultado(p_resultado.COUNT) := v_transaccion;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END LOOP;
    END procedure_obtener_transacciones_por_ids;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_transacciones_hoy(
        o_resultado OUT t_lista_transacciones
    ) IS
        v_transaccion t_info_transaccion;
    BEGIN
        o_resultado := t_lista_transacciones();

        -- Usa el cursor básico declarado
        FOR reg IN c_transacciones_hoy LOOP
            v_transaccion.id_transaccion := reg.id_transaccion;
            v_transaccion.monto_transaccion := reg.monto_transaccion;
            v_transaccion.fecha_transaccion := reg.fecha_transaccion;
            v_transaccion.estado_transaccion := reg.estado_transaccion;
            v_transaccion.tipo_transaccion := reg.tipo_transaccion;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_transaccion;
        END LOOP;
    END procedure_listar_transacciones_hoy;
END pkgc_transacciones;


/
--------------------------------------------------------
--  DDL for Package Body PKG_CUENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKG_CUENTA" AS
    -- ========== CURSOR BÁSICO ==========
    CURSOR c_cuentas_activas IS
        SELECT id_cuenta, id_cliente, saldo_cuenta, estado_cuenta
        FROM cuenta
        WHERE estado_cuenta = 'activa'
        ORDER BY id_cuenta;

    FUNCTION function_login_cuenta(p_email IN VARCHAR2, p_contrasena IN VARCHAR2) RETURN NUMBER IS
        v_id_cuenta NUMBER;
    BEGIN
        SELECT c.id_cuenta INTO v_id_cuenta
        FROM cuenta c JOIN cliente cli ON cli.id_cliente = c.id_cliente
        WHERE UPPER(cli.email_cliente) = UPPER(p_email)
          AND c.contrasena_cuenta = p_contrasena
          AND c.estado_cuenta = 'activa';
        RETURN v_id_cuenta;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN RETURN NULL;
    END function_login_cuenta;

    FUNCTION function_generar_id_cuenta RETURN NUMBER IS
        v_id NUMBER;
    BEGIN
        SELECT NVL(MAX(id_cuenta), 0) + 1 INTO v_id FROM cuenta;
        RETURN v_id;
    END function_generar_id_cuenta;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_crear_cuenta
    -------------------------------------------------------------------
    PROCEDURE procedure_crear_cuenta(
        p_id_cliente       IN VARCHAR2,
        p_id_administrador IN NUMBER,
        o_id_cuenta        OUT NUMBER
    ) IS
        v_cliente_count NUMBER;
        v_admin_count   NUMBER;
        v_cedula_cliente NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_cliente_count
        FROM cliente
        WHERE id_cliente = p_id_cliente;

        IF v_cliente_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El cliente no existe: ' || p_id_cliente);
        END IF;

        SELECT COUNT(*) INTO v_admin_count
        FROM administrador
        WHERE id_administrador = p_id_administrador;

        IF v_admin_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 'El administrador no existe: ' || p_id_administrador);
        END IF;

        SELECT cedula_cliente INTO v_cedula_cliente
        FROM cliente
        WHERE id_cliente = p_id_cliente;

        o_id_cuenta := function_generar_id_cuenta();

        INSERT INTO cuenta (
            id_cuenta,
            id_cliente,
            id_administrador,
            saldo_cuenta,
            fecha_creacion_cuenta,
            estado_cuenta,
            contrasena_cuenta,
            fecha_ultima_transaccion_cuenta
        ) VALUES (
            o_id_cuenta,
            p_id_cliente,
            p_id_administrador,
            0,
            SYSTIMESTAMP,
            'activa',
            v_cedula_cliente,
            NULL
        );
    END procedure_crear_cuenta;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_consultar_cuentas_por_cliente
    -- EXPLAIN PLAN: Consulta principal para listar cuentas por cliente
    -------------------------------------------------------------------
    PROCEDURE procedure_consultar_cuentas_por_cliente(
        p_id_cliente IN VARCHAR2,
        result OUT SYS_REFCURSOR
    ) IS
    BEGIN
        -- Abrir el cursor con la consulta (SIN EXPLAIN PLAN)
        OPEN result FOR
            SELECT 
                id_cuenta,
                saldo_cuenta,
                estado_cuenta,
                fecha_creacion_cuenta
            FROM cuenta
            WHERE id_cliente = p_id_cliente
            ORDER BY id_cuenta;
            
    EXCEPTION
        WHEN OTHERS THEN
            -- Cerrar el cursor si está abierto antes de relanzar el error
            IF result%ISOPEN THEN
                CLOSE result;
            END IF;
            RAISE;
    END procedure_consultar_cuentas_por_cliente;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_consultar_cuentas_por_id
    -------------------------------------------------------------------
    PROCEDURE procedure_consultar_cuentas_por_id(
        p_id_cuenta IN NUMBER,
        result OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN result FOR
            SELECT 
                id_cuenta,
                id_cliente,
                saldo_cuenta,
                estado_cuenta,
                fecha_creacion_cuenta,
                fecha_ultima_transaccion_cuenta
            FROM cuenta
            WHERE id_cuenta = p_id_cuenta;
    END procedure_consultar_cuentas_por_id;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_actualizar_cuenta
    -------------------------------------------------------------------
    PROCEDURE procedure_actualizar_cuenta(
        p_id_cuenta   IN NUMBER,
        p_saldo       IN NUMBER DEFAULT NULL,
        p_estado      IN VARCHAR2 DEFAULT NULL
    ) IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20003,'La cuenta no existe.');
        END IF;

        IF p_estado IS NOT NULL AND p_estado NOT IN ('activa','inactiva') THEN
            RAISE_APPLICATION_ERROR(-20004,'Estado inválido para cuenta.');
        END IF;

        UPDATE cuenta
        SET saldo_cuenta = NVL(p_saldo, saldo_cuenta),
            estado_cuenta = NVL(p_estado, estado_cuenta)
        WHERE id_cuenta = p_id_cuenta;
    END procedure_actualizar_cuenta;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_cambiar_saldo
    -------------------------------------------------------------------
    PROCEDURE procedure_cambiar_saldo(
        p_id_cuenta IN NUMBER,
        p_monto     IN NUMBER
    ) IS
        v_saldo NUMBER;
        v_count NUMBER;
    BEGIN
        -- Validar que la cuenta existe
        SELECT COUNT(*) INTO v_count
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20008, 'La cuenta no existe.');
        END IF;

        -- Obtener saldo actual
        SELECT saldo_cuenta INTO v_saldo
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        -- Validar que el saldo no quede negativo
        IF v_saldo + p_monto < 0 THEN
            RAISE_APPLICATION_ERROR(-20005, 'El saldo no puede quedar negativo.');
        END IF;

        -- Actualizar saldo
        UPDATE cuenta
        SET saldo_cuenta = v_saldo + p_monto,
            fecha_ultima_transaccion_cuenta = SYSTIMESTAMP
        WHERE id_cuenta = p_id_cuenta;
    END procedure_cambiar_saldo;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_eliminar_cuenta
    -------------------------------------------------------------------
    PROCEDURE procedure_eliminar_cuenta(
        p_id_cuenta IN NUMBER
    ) IS
        v_exists NUMBER;
        v_estado VARCHAR2(10);
    BEGIN
        SELECT COUNT(*) INTO v_exists
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20006,'La cuenta no existe.');
        END IF;

        SELECT estado_cuenta INTO v_estado
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_estado = 'inactiva' THEN
            DBMS_OUTPUT.PUT_LINE('La cuenta ya estaba inactiva.');
            RETURN;
        END IF;

        UPDATE cuenta
        SET estado_cuenta = 'inactiva',
            fecha_ultima_transaccion_cuenta = SYSTIMESTAMP
        WHERE id_cuenta = p_id_cuenta;
    END procedure_eliminar_cuenta;

    -------------------------------------------------------------------
    -- Procedimiento: procedure_cambiar_contrasena
    -------------------------------------------------------------------
    PROCEDURE procedure_cambiar_contrasena(
        p_id_cuenta        IN NUMBER,
        p_nueva_contrasena IN VARCHAR2
    ) IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM cuenta
        WHERE id_cuenta = p_id_cuenta;

        IF v_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20007,'La cuenta no existe.');
        END IF;

        UPDATE cuenta
        SET contrasena_cuenta = p_nueva_contrasena
        WHERE id_cuenta = p_id_cuenta;
    END procedure_cambiar_contrasena;

    -- ========== NUEVO PROCEDIMIENTO CON COLECCIONES ==========
    PROCEDURE procedure_obtener_cuentas_por_ids(
        p_ids IN t_lista_ids_cuenta,
        p_resultado OUT t_lista_cuentas
    ) IS
        v_cuenta t_info_cuenta;
    BEGIN
        p_resultado := t_lista_cuentas();

        FOR i IN 1..p_ids.COUNT LOOP
            BEGIN
                SELECT id_cuenta, id_cliente, saldo_cuenta, estado_cuenta
                INTO v_cuenta.id_cuenta, v_cuenta.id_cliente, 
                     v_cuenta.saldo_cuenta, v_cuenta.estado_cuenta
                FROM cuenta
                WHERE id_cuenta = p_ids(i);

                p_resultado.EXTEND;
                p_resultado(p_resultado.COUNT) := v_cuenta;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL; -- Continuar con el siguiente
            END;
        END LOOP;
    END procedure_obtener_cuentas_por_ids;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_cuentas_activas(
        o_resultado OUT t_lista_cuentas
    ) IS
        v_cuenta t_info_cuenta;
    BEGIN
        o_resultado := t_lista_cuentas();

        -- Usa el cursor básico declarado
        FOR reg IN c_cuentas_activas LOOP
            v_cuenta.id_cuenta := reg.id_cuenta;
            v_cuenta.id_cliente := reg.id_cliente;
            v_cuenta.saldo_cuenta := reg.saldo_cuenta;
            v_cuenta.estado_cuenta := reg.estado_cuenta;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_cuenta;
        END LOOP;
    END procedure_listar_cuentas_activas;
END pkg_cuenta;


/
--------------------------------------------------------
--  DDL for Package Body PKG_SUCURSAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PKG_SUCURSAL" AS
    -- ========== CURSOR BÁSICO ==========
    CURSOR c_sucursales_abiertas IS
        SELECT id_sucursal, nombre_sucursal, direccion_sucursal, 
               telefono_sucursal, estado_sucursal, id_administrador
        FROM sucursal
        WHERE estado_sucursal = 'abierta'
        ORDER BY id_sucursal;

    PROCEDURE procedure_listar_sucursales(
        o_cursor OUT SYS_REFCURSOR
    )
    IS
    BEGIN
        OPEN o_cursor FOR
            SELECT 
                id_sucursal,
                nombre_sucursal,
                direccion_sucursal,
                telefono_sucursal,
                estado_sucursal,
                id_administrador
            FROM sucursal
            ORDER BY id_sucursal;
    END procedure_listar_sucursales;

    ---------------------------------------------------------------------
    -- FUNCIÓN: CREAR SUCURSAL
    -- Compatible con servicio C#
    ---------------------------------------------------------------------
    FUNCTION function_crear_sucursal(
        p_nombre      IN VARCHAR2,
        p_direccion   IN VARCHAR2,
        p_telefono    IN VARCHAR2,
        p_id_admin    IN NUMBER
    ) RETURN NUMBER
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;

        v_new_id NUMBER;
        v_admin NUMBER;
        v_count NUMBER;

        v_nombre    VARCHAR2(200);
        v_direccion VARCHAR2(200);
        v_telefono  VARCHAR2(50);
    BEGIN
        -----------------------------------------------------------------
        -- 1. Limpiar datos
        -----------------------------------------------------------------
        v_nombre :=
            TRIM(REPLACE(REPLACE(p_nombre, CHR(10), ''), CHR(13), ''));

        v_direccion :=
            TRIM(REPLACE(REPLACE(p_direccion, CHR(10), ''), CHR(13), ''));

        v_telefono :=
            TRIM(REPLACE(REPLACE(p_telefono, CHR(10), ''), CHR(13), ''));

        -----------------------------------------------------------------
        -- 2. Si p_id_admin es NULL → usar administrador por defecto: 1
        -----------------------------------------------------------------
        v_admin := NVL(p_id_admin, 1);

        -----------------------------------------------------------------
        -- 3. Validar que el administrador existe
        -----------------------------------------------------------------
        SELECT COUNT(*) INTO v_count
        FROM administrador
        WHERE id_administrador = v_admin;

        IF v_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20010,
                'El administrador con ID ' || v_admin || ' no existe.');
        END IF;

        -----------------------------------------------------------------
        -- 4. Generar ID nuevo
        -----------------------------------------------------------------
        SELECT NVL(MAX(id_sucursal), 0) + 1 INTO v_new_id
        FROM sucursal;

        -----------------------------------------------------------------
        -- 5. Insertar sucursal
        -----------------------------------------------------------------
        INSERT INTO sucursal (
            id_sucursal,
            nombre_sucursal,
            direccion_sucursal,
            telefono_sucursal,
            estado_sucursal,
            id_administrador
        )
        VALUES (
            v_new_id,
            v_nombre,
            v_direccion,
            v_telefono,
            'abierta',      -- por defecto
            v_admin
        );

        COMMIT;

        RETURN v_new_id;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END function_crear_sucursal;

    ---------------------------------------------------------------------
    -- PROCEDIMIENTO: EDITAR ESTADO
    ---------------------------------------------------------------------
    PROCEDURE procedure_editar_estado(
        p_id_sucursal IN NUMBER,
        p_estado      IN VARCHAR2
    )
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        IF LOWER(p_estado) NOT IN ('abierta','cerrada') THEN
            RAISE_APPLICATION_ERROR(-20003,
                ' Estado inválido. Debe ser: abierta / cerrada');
        END IF;

        UPDATE sucursal
        SET estado_sucursal = LOWER(p_estado)
        WHERE id_sucursal = p_id_sucursal;

        IF SQL%ROWCOUNT = 0 THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR(-20004,
                'No existe la sucursal con ID ' || p_id_sucursal);
        END IF;

        COMMIT;
    END procedure_editar_estado;

    ---------------------------------------------------------------------
    -- PROCEDIMIENTO: ELIMINAR SUCURSAL
    ---------------------------------------------------------------------
    PROCEDURE procedure_eliminar_sucursal(
        p_id_sucursal IN NUMBER
    )
    IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        DELETE FROM sucursal
        WHERE id_sucursal = p_id_sucursal;

        IF SQL%ROWCOUNT = 0 THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR(-20005,
                'No existe la sucursal con ID ' || p_id_sucursal);
        END IF;

        COMMIT;
    END procedure_eliminar_sucursal;

    -- ========== NUEVO PROCEDIMIENTO CON COLECCIONES ==========
    PROCEDURE procedure_obtener_sucursales_por_ids(
        p_ids IN t_lista_ids_sucursal,
        p_resultado OUT t_lista_sucursales
    ) IS
        v_sucursal t_info_sucursal;
    BEGIN
        p_resultado := t_lista_sucursales();

        FOR i IN 1..p_ids.COUNT LOOP
            BEGIN
                SELECT id_sucursal, nombre_sucursal, direccion_sucursal,
                       telefono_sucursal, estado_sucursal, id_administrador
                INTO v_sucursal.id_sucursal, v_sucursal.nombre_sucursal,
                     v_sucursal.direccion_sucursal, v_sucursal.telefono_sucursal,
                     v_sucursal.estado_sucursal, v_sucursal.id_administrador
                FROM sucursal
                WHERE id_sucursal = p_ids(i);

                p_resultado.EXTEND;
                p_resultado(p_resultado.COUNT) := v_sucursal;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    NULL;
            END;
        END LOOP;
    END;

    -- ========== PROCEDIMIENTO QUE USA EL CURSOR BÁSICO ==========
    PROCEDURE procedure_listar_sucursales_abiertas(
        o_resultado OUT t_lista_sucursales
    ) IS
        v_sucursal t_info_sucursal;
    BEGIN
        o_resultado := t_lista_sucursales();

        -- Usa el cursor básico declarado
        FOR reg IN c_sucursales_abiertas LOOP
            v_sucursal.id_sucursal := reg.id_sucursal;
            v_sucursal.nombre_sucursal := reg.nombre_sucursal;
            v_sucursal.direccion_sucursal := reg.direccion_sucursal;
            v_sucursal.telefono_sucursal := reg.telefono_sucursal;
            v_sucursal.estado_sucursal := reg.estado_sucursal;
            v_sucursal.id_administrador := reg.id_administrador;

            o_resultado.EXTEND;
            o_resultado(o_resultado.COUNT) := v_sucursal;
        END LOOP;
    END procedure_listar_sucursales_abiertas;
END pkg_sucursal;


/
--------------------------------------------------------
--  Constraints for Table CUENTA
--------------------------------------------------------

  ALTER TABLE "CUENTA" MODIFY ("ID_CLIENTE" NOT NULL ENABLE);
  ALTER TABLE "CUENTA" MODIFY ("ID_ADMINISTRADOR" NOT NULL ENABLE);
  ALTER TABLE "CUENTA" ADD CONSTRAINT "CK_CUENTA_SALDO" CHECK (SALDO_CUENTA >= 0) ENABLE;
  ALTER TABLE "CUENTA" ADD CONSTRAINT "CK_CUENTA_ESTADO" CHECK (ESTADO_CUENTA IN ('activa','inactiva')) ENABLE;
  ALTER TABLE "CUENTA" ADD CONSTRAINT "PK_CUENTA" PRIMARY KEY ("ID_CUENTA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CLIENTE
--------------------------------------------------------

  ALTER TABLE "CLIENTE" ADD CONSTRAINT "CK_CLIENTE_ESTADO" CHECK (ESTADO_CLIENTE IN ('ACTIVO','INACTIVO')) ENABLE;
  ALTER TABLE "CLIENTE" ADD CONSTRAINT "PK_CLIENTE" PRIMARY KEY ("ID_CLIENTE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CLIENTE" ADD CONSTRAINT "UQ_CLIENTE_EMAIL" UNIQUE ("EMAIL_CLIENTE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CLIENTE" ADD CONSTRAINT "UQ_CLIENTE_CEDULA" UNIQUE ("CEDULA_CLIENTE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SUCURSAL
--------------------------------------------------------

  ALTER TABLE "SUCURSAL" ADD CONSTRAINT "CK_SUCURSAL_ESTADO" CHECK (ESTADO_SUCURSAL IN ('abierta','cerrada')) ENABLE;
  ALTER TABLE "SUCURSAL" ADD CONSTRAINT "PK_SUCURSAL" PRIMARY KEY ("ID_SUCURSAL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TARJETA
--------------------------------------------------------

  ALTER TABLE "TARJETA" ADD CONSTRAINT "CK_TARJETA_ESTADO" CHECK (
        ESTADO_TARJETA IN ('activa','inactiva','bloqueada','suspendida')
    ) ENABLE;
  ALTER TABLE "TARJETA" ADD CONSTRAINT "PK_TARJETA" PRIMARY KEY ("ID_TARJETA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "TARJETA" ADD CONSTRAINT "UQ_TARJETA_NUMERO" UNIQUE ("NUMERO_TARJETA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TARJETA_DEBITO
--------------------------------------------------------

  ALTER TABLE "TARJETA_DEBITO" ADD CONSTRAINT "CK_DEBITO_LIMITE" CHECK (LIMITE_RETIRO_DEBITO >= 0) ENABLE;
  ALTER TABLE "TARJETA_DEBITO" ADD CONSTRAINT "CK_DEBITO_SALDO" CHECK (SALDO_ACTUAL_DEBITO >= 0) ENABLE;
  ALTER TABLE "TARJETA_DEBITO" ADD CONSTRAINT "PK_TARJETA_DEBITO" PRIMARY KEY ("ID_TARJETA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CUOTA
--------------------------------------------------------

  ALTER TABLE "CUOTA" ADD CONSTRAINT "CK_CUOTA_MONTO_CAPITAL" CHECK (MONTO_DE_CUOTA >= CAPITAL_CUOTA AND CAPITAL_CUOTA >= 0) ENABLE;
  ALTER TABLE "CUOTA" ADD CONSTRAINT "CK_CUOTA_NUM" CHECK (NUMERO_CUOTA > 0) ENABLE;
  ALTER TABLE "CUOTA" ADD CONSTRAINT "CK_CUOTA_MONTOS" CHECK (MONTO_DE_CUOTA >= 0 AND CAPITAL_CUOTA >= 0) ENABLE;
  ALTER TABLE "CUOTA" ADD CONSTRAINT "CK_CUOTA_ESTADO" CHECK (ESTADO_CUOTA IN ('pendiente','pagada','mora')) ENABLE;
  ALTER TABLE "CUOTA" ADD CONSTRAINT "PK_CUOTA" PRIMARY KEY ("ID_CUOTA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "CUOTA" ADD CONSTRAINT "UQ_CUOTA_PRESTAMO" UNIQUE ("ID_PRESTAMO", "NUMERO_CUOTA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ADMINISTRADOR
--------------------------------------------------------

  ALTER TABLE "ADMINISTRADOR" ADD CONSTRAINT "PK_ADMINISTRADOR" PRIMARY KEY ("ID_ADMINISTRADOR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUDITORIA_CAMBIOS
--------------------------------------------------------

  ALTER TABLE "AUDITORIA_CAMBIOS" ADD PRIMARY KEY ("ID_AUDITORIA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PRESTAMO
--------------------------------------------------------

  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "CK_PRESTAMO_ESTADO" CHECK (estado_prestamo IN (
    'solicitado',
    'activo',
    'mora',
    'finalizado',
    'rechazado'
)) ENABLE;
  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "CK_PRESTAMO_PLAZO" CHECK (
    (estado_prestamo = 'solicitado' AND plazo_prestamo = 0)
    OR
    (estado_prestamo <> 'solicitado' AND plazo_prestamo > 0)
) ENABLE;
  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "CK_PRESTAMO_MONTO" CHECK (MONTO_PRESTAMO > 0) ENABLE;
  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "CK_PRESTAMO_TASA" CHECK (TASA_DE_INTERES_PRESTAMO BETWEEN 0 AND 15) ENABLE;
  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "CK_PRESTAMO_SALDO" CHECK (SALDO_PRESTAMO >= 0) ENABLE;
  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "PK_PRESTAMO" PRIMARY KEY ("ID_PRESTAMO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "PRESTAMO" MODIFY ("ID_CUENTA" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TARJETA_CREDITO
--------------------------------------------------------

  ALTER TABLE "TARJETA_CREDITO" ADD CONSTRAINT "CK_CREDITO_TASA" CHECK (TASA_INTERES_CREDITO >= 0) ENABLE;
  ALTER TABLE "TARJETA_CREDITO" ADD CONSTRAINT "CK_CREDITO_LIMITE" CHECK (LIMITE_CREDITO >= 0) ENABLE;
  ALTER TABLE "TARJETA_CREDITO" ADD CONSTRAINT "CK_CREDITO_CUOTA" CHECK (CUOTA_MANEJO_CREDITO >= 0) ENABLE;
  ALTER TABLE "TARJETA_CREDITO" ADD CONSTRAINT "CK_CREDITO_CORTE" CHECK (FECHA_CORTE_CREDITO BETWEEN 1 AND 31) ENABLE;
  ALTER TABLE "TARJETA_CREDITO" ADD CONSTRAINT "PK_TARJETA_CREDITO" PRIMARY KEY ("ID_TARJETA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ABONO_EXTRAORDINARIO
--------------------------------------------------------

  ALTER TABLE "ABONO_EXTRAORDINARIO" ADD CONSTRAINT "CK_ABONO_MONTO" CHECK (MONTO_ABONO > 0) ENABLE;
  ALTER TABLE "ABONO_EXTRAORDINARIO" ADD CONSTRAINT "CK_ABONO_TIPO" CHECK (
        TIPO_ABONO IN ('reduccion de plazo','reduccion de cuota')
    ) ENABLE;
  ALTER TABLE "ABONO_EXTRAORDINARIO" ADD CONSTRAINT "PK_ABONO" PRIMARY KEY ("ID_ABONO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "ABONO_EXTRAORDINARIO" ADD CONSTRAINT "UQ_ABONO_TRX" UNIQUE ("ID_TRANSACCION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CAJERO
--------------------------------------------------------

  ALTER TABLE "CAJERO" ADD CONSTRAINT "CK_CAJERO_DINERO" CHECK (DINERO_DISPONIBLE_CAJERO >= 0) ENABLE;
  ALTER TABLE "CAJERO" ADD CONSTRAINT "CK_CAJERO_ESTADO" CHECK (ESTADO_CAJERO IN ('activo','inactivo')) ENABLE;
  ALTER TABLE "CAJERO" ADD CONSTRAINT "PK_CAJERO" PRIMARY KEY ("ID_CAJERO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TRANSACCION
--------------------------------------------------------

  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "CK_TRX_TIPO" CHECK (TIPO_TRANSACCION IN ('cuenta','cajero')) ENABLE;
  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "CK_TRX_MONTO" CHECK (MONTO_TRANSACCION > 0) ENABLE;
  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "CK_TRX_ESTADO" CHECK (
        ESTADO_TRANSACCION IN ('completada','pendiente','fallida','cancelada')
    ) ENABLE;
  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "PK_TRANSACCION" PRIMARY KEY ("ID_TRANSACCION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ABONO_EXTRAORDINARIO
--------------------------------------------------------

  ALTER TABLE "ABONO_EXTRAORDINARIO" ADD CONSTRAINT "FK_ABONO_PRESTAMO" FOREIGN KEY ("ID_PRESTAMO")
	  REFERENCES "PRESTAMO" ("ID_PRESTAMO") ENABLE;
  ALTER TABLE "ABONO_EXTRAORDINARIO" ADD CONSTRAINT "FK_ABONO_TRX" FOREIGN KEY ("ID_TRANSACCION")
	  REFERENCES "TRANSACCION" ("ID_TRANSACCION") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CAJERO
--------------------------------------------------------

  ALTER TABLE "CAJERO" ADD CONSTRAINT "FK_CAJERO_SUCURSAL" FOREIGN KEY ("ID_SUCURSAL")
	  REFERENCES "SUCURSAL" ("ID_SUCURSAL") ENABLE;
  ALTER TABLE "CAJERO" ADD CONSTRAINT "FK_CAJERO_ADMIN" FOREIGN KEY ("ID_ADMINISTRADOR")
	  REFERENCES "ADMINISTRADOR" ("ID_ADMINISTRADOR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CUENTA
--------------------------------------------------------

  ALTER TABLE "CUENTA" ADD CONSTRAINT "FK_CUENTA_CLIENTE" FOREIGN KEY ("ID_CLIENTE")
	  REFERENCES "CLIENTE" ("ID_CLIENTE") ENABLE;
  ALTER TABLE "CUENTA" ADD CONSTRAINT "FK_CUENTA_ADMIN" FOREIGN KEY ("ID_ADMINISTRADOR")
	  REFERENCES "ADMINISTRADOR" ("ID_ADMINISTRADOR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CUOTA
--------------------------------------------------------

  ALTER TABLE "CUOTA" ADD CONSTRAINT "FK_CUOTA_PRESTAMO" FOREIGN KEY ("ID_PRESTAMO")
	  REFERENCES "PRESTAMO" ("ID_PRESTAMO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table PRESTAMO
--------------------------------------------------------

  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "FK_PRESTAMO_SUCURSAL" FOREIGN KEY ("ID_SUCURSAL")
	  REFERENCES "SUCURSAL" ("ID_SUCURSAL") ENABLE;
  ALTER TABLE "PRESTAMO" ADD CONSTRAINT "FK_PRESTAMO_CUENTA" FOREIGN KEY ("ID_CUENTA")
	  REFERENCES "CUENTA" ("ID_CUENTA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SUCURSAL
--------------------------------------------------------

  ALTER TABLE "SUCURSAL" ADD CONSTRAINT "FK_SUCURSAL_ADMIN" FOREIGN KEY ("ID_ADMINISTRADOR")
	  REFERENCES "ADMINISTRADOR" ("ID_ADMINISTRADOR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TARJETA
--------------------------------------------------------

  ALTER TABLE "TARJETA" ADD CONSTRAINT "FK_TARJETA_CUENTA" FOREIGN KEY ("ID_CUENTA")
	  REFERENCES "CUENTA" ("ID_CUENTA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TARJETA_CREDITO
--------------------------------------------------------

  ALTER TABLE "TARJETA_CREDITO" ADD CONSTRAINT "FK_CREDITO_TARJETA" FOREIGN KEY ("ID_TARJETA")
	  REFERENCES "TARJETA" ("ID_TARJETA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TARJETA_DEBITO
--------------------------------------------------------

  ALTER TABLE "TARJETA_DEBITO" ADD CONSTRAINT "FK_DEBITO_TARJETA" FOREIGN KEY ("ID_TARJETA")
	  REFERENCES "TARJETA" ("ID_TARJETA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TRANSACCION
--------------------------------------------------------

  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "FK_TRX_CAJERO" FOREIGN KEY ("ID_CAJERO")
	  REFERENCES "CAJERO" ("ID_CAJERO") ENABLE;
  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "FK_TRX_TARJETA" FOREIGN KEY ("ID_TARJETA")
	  REFERENCES "TARJETA" ("ID_TARJETA") ENABLE;
  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "FK_TRX_CTA_ORIGEN" FOREIGN KEY ("ID_CUENTA_ORIGEN")
	  REFERENCES "CUENTA" ("ID_CUENTA") ENABLE;
  ALTER TABLE "TRANSACCION" ADD CONSTRAINT "FK_TRX_CTA_DEST" FOREIGN KEY ("ID_CUENTA_DESTINO")
	  REFERENCES "CUENTA" ("ID_CUENTA") ENABLE;
